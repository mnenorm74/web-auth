# Auth

## 0. Подготовка

Требуется научиться запускать приложение `PhotosApp` и убедиться, что все хорошо.


Приложение использует https, поэтому для корректной работы понадобится сертификат.
.NET Core умеет создавать сертификаты для localhost. Только надо установить такой сертификат в доверенные.
Для этого запусти команду:
```
dotnet dev-certs https --trust
```


Запусти приложение под отладкой. Должен запусться браузер и открыть стартовую страницу приложения.
Убедись, что при запуске в папке `PhotosApp` автоматически создался файл `PhotosApp.db` с базой данных Sqlite.

Открой файл `PhotosApp.db` с помощью сервиса https://sqliteonline.com/.
Убедись, что в нем есть таблица `Photos`, выведи записи из нее.


На всякий случай небольшой ликбез.

В этом задании надо будет часто подключать `using` к файлу после вставки кода.
Вручную прописывать `using` не надо. Надо установить курсор на слово с неизвестным типом,
нажать мышкой на появившуюся слева лампочку и выбрать команду добавляющую `using`.

Конечно, проще это сделать с помощью сочетания клавиш:

- Visual Studio Code: `Ctrl+.`
- Visual Studio: `Ctrl+.` или `Alt+Enter`
- ReSharper: `Alt+Enter`
- Rider: `Alt+Enter`

В этом задании придется работать с большим количеством файлов и может быть удобно
искать файлы по имени, а также типы по имени. Обычно IDE это прекрасно умеют делать:
главное знать сочетание клавиш для этого функционала.

Используй сочетание клавиш для своей IDE и найди в решении файл `RemotePhotosRepository.cs`:

- Visual Studio Code: `Ctrl+T`
- Visual Studio: `Ctrl+T`
- ReSharper: `Ctrl+T`
- Rider: `Ctrl+T` или `Shift, Shift`


## 1. Identity

### 1.1. Scaffolding

Требуется сгенерировать код `Identity`, а затем ее корректно подключить к приложению `PhotosApp`.

*Scaffolding (англ. строительные леса) — генерация кода по заданной разработчиком спецификации.*

Прежде всего потребуется установить новый инструмент для .NET Core CLI — генератор кода:
```
dotnet tool install -g dotnet-aspnet-codegenerator
```

Кроме того, в проект надо добавить NuGet-пакеты для кодогенерации.
Выполни в папке с проектом PhotosApp:
```
dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
dotnet add package Microsoft.EntityFrameworkCore.Design
```

Наконец, можно выполнить команду генерации кода `Identity` (также в папке с проектом PhotosApp):
```
dotnet aspnet-codegenerator identity -dc UsersDbContext -u PhotoAppUser -sqlite
```

Дополнительные параметры команды указывают:

- имя `DbContext`, который будет использоваться для хранения информации о пользователях,
- класс пользователя, хранимого в базе данных,
- что, в качестве базы данных надо использовать Sqlite, а не SQL Server.


В проекте `PhotosApp` в папке `Areas/Identity` был сгенерирован требующийся код.

`Area` в ASP.NET Core MVC — это в каком-то смысле подприложение с собственной адресацией.
В случае `Identity` все адреса страниц будут иметь префикс `/Indentity`, после которого будет обычный путь до страницы.

Посмотри структуру папки  `Areas/Identity`.
Обрати внимание на файл `Areas/Identity/IdentityHostingStartup.cs`.
Код из него будет автоматически запускаться после `Startup.cs` и завершать конфигурирование.
Также обрати внимание, что страницы сгенерированы по технологии `Razor Pages`.
В отличие от MVC, где «разметка» (View) и «обработка» (Controller) находится в разных местах,
здесь все находится в двух соседних файлах. Например, для страницы `Identity/Pages/Account/Login.cshtml`,
разметка находится в `Login.cshtml`, а обработка в `Login.cshtml.cs`.


Чтобы `Razor Pages` заработали, надо их добавить в контейнер, а также подключить в качестве обработчиков запросов.

Код для `ConfigureServices`:
```cs
var mvc = services.AddControllersWithViews();
services.AddRazorPages();
if (env.IsDevelopment())
    mvc.AddRazorRuntimeCompilation();
```
*Замечение. Раз `AddRazorRuntimeCompilation` в подключается контексте `AddControllersWithViews`,*
*то для `AddRazorPages` можно снова не подключать.*
*Компиляция представлений на лету без перестроения всего проекта будет работать и для razor pages.*

Код для `Configure`:
```cs
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute("default", "{controller=Photo}/{action=Index}/{id?}");
    endpoints.MapRazorPages();
});
```


Также в `Views/Shared` был сгенерирован `_LoginPartial.cshtml`, содержищий разметку для отображения
ссылок для регистрации/входа/выхода пользователя в меню приложения.

Ссылки регистрации/входа/выхода надо добавить в меню приложения.
Для этого открой `Views/Shared/_Layout.cshtml` и добавь вставку `_LoginPartial.cshtml` с помощью tag-хелпера
сразу после других ссылок:
```cshtml
<ul class="navbar-nav mr-auto">
    ...
</ul>
<partial name="_LoginPartial"/>
```

Можешь убедиться, что ссылки появились и при переходе по ним открываются страницы `Identity`.

Только ничего не работает, потому что пользователей нет, да и таблица базы данных для них еще не создана.


### 1.2. Миграции

Для манипулирования базой данных нужно установить инструмент Entity Framework Core для .NET CLI:
```
dotnet tool install --global dotnet-ef
```

В коде появился новый контекст. Чтобы обновить БД для хранения данных из него, надо создать миграцию:
```
dotnet ef migrations add Users --context UsersDbContext
```
Миграция — это план обновления. Его можно применять к БД, которыми будет пользоваться приложение.

Чтобы миграция успешно создалась:

1. Приложение должно компилироваться без ошибок,
2. При старте приложения не должно быть ошибок,
т.е. код конфигурирования (в `Startup.cs` и `IdentityHostingStartup.cs`) должен работать корректно
3. Приложение не должно быть запущенным.
Все это нужно, чтобы команда миграции смогла построить и запустить проект,
а затем получить через рефлексию всю необходимую информацию о контексте.

Если при запуске миграции встретилась такая замысловатая ошибка про «design time», проверь предыдущие три пункта.
`Unable to create an object of type 'UsersDbContext'. For the different patterns supported at design time, see https://go.microsoft.com/fwlink/?linkid=851728`


После создания миграции ее надо запустить на имеющейся базе данных Sqlite.
Сделай это с помощью следующей команды:
```
dotnet ef database update --context UsersDbContext
```
Теперь база данных обновлена и в ней можно хранить информацию о пользователях.
Посмотри с помощью https://sqliteonline.com/ какие таблицы были созданы. Заметь, что их достаточно много.


Для целей разработки можно вместо `dotnet ef database update` использовать такой вызов метода:
```cs
dbContext.Database.Migrate()
```
Здесь `dbContext` — экземпляр класса-наследника `DbContext`.

Посмотри как этот метод используется в файле `Data/DataExtensions.cs` для `PhotosDbContext`,
и напиши аналогичный код для `UsersDbContext`.
В результате, если файл `PhotosApp.db` удален, то при запуске приложения
он автоматически восстановится со всеми таблицами.


Теперь надо добавить тестовых пользователей.
Это умеет делат метод `SeedWithSampleUsersAsync` из `Data/DataExtensions.cs`.
Вызови его в `PrepareDB`, чтобы при старте приложения создавались тестовые пользователи.
Подсказка: `UserManager<PhotoAppUser>` можно достать из `ServiceProvider`.


### 1.3. Аутентификация

Чтобы под пользователем можно было зайти, подключи middleware аутентификации `UseAuthentication`
 и middleware авторизации `UseAuthorization` в `Startup.cs`.
Их вызов обязательно должен быть после подключения middleware для определения обработчика запроса (`UseRouting`),
но перед подключением middleware для выполнения запроса (`UseEndpoints`).
Это позволит слою `UseAuthorization` проверить пользователя на соответствие требованиям обработчика,
который стал известен после `UseRouting`, и отменить выполнение обработки в `UseEndpoints`,
если у пользователя не хватает прав. Слой `UseAuthentication` также пользуется информацией из `UseRouting`.
Должно получиться так:
```cs
app.UseRouting();

app.UseAuthentication();
app.UseAuthorization();

app.UseEndpoints(endpoints => ...);
```


Теперь попробуй зайти под пользователем `cristina`. Пароль можно найти в `Data/DataExtensions.cs`.


Но даже если зайти под нужным пользователем, его фотки не будут показываться, пока не поправить `PhotoController`.
Измени метод `GetOwnerId` так, чтобы он возвращал идентификатор залогиненного пользователя, а не идентификатор `vicky`:
```cs
private string GetOwnerId()
{
    return User.FindFirstValue(ClaimTypes.NameIdentifier);
}
```


Снова зайди под `cristina`, а затем под `vicky`. Фотографии должны быть разными.


Осталась пара нюансов.

1. При заходе на страницы управления аккаунтом (кликни на имя пользователя в меню приложения, чтобы туда попасть)
показывается неправильная шапка страницы.
Чтобы починить в файле `/Areas/Identity/Pages/Account/Manage/_Layout.cshtml` поменяй `Layout`.
Корректное значение для приложения — `"/Views/Shared/_Layout.cshtml"`

2. Logout работает некорректно. После него не происходит перехода на главную страницу приложения,
а в верхнем меню остается имя пользователя. Это происходит потому, что в `_LoginPartial.cshtml`
указан некорректный `asp-route-returnUrl`. Должен быть `@Url.Action("Index", "Photo", new { area = "" })`.


### 1.4. Авторизация

Теперь надо сделать, чтобы анонимный пользователь автоматически пересылался на страницу входа
при выполнении любых действий с фотографиями. Доступной должна остаться только главная страница.

Для этого достаточно пометить атрибутом `[Authorize]` все методы или контроллеры, которые требуется защитить.
Если пометить атрибутом `[Authorize]` контроллер, но надо разрешить некоторый метод, то метод помечается
атрибутом `[AllowAnonymous]`.

Защити все действия над фотографиями из `PhotoController`, кроме `Index`.


### 1.5. Требования к паролям

Настройки по умолчанию для паролей хороши:

- есть требования на длину и используемые символы,
- пароли не хранятся о открытом виде, а хэшируются с солью.

Но такие настройки не всегда подходят.

В большинстве случаев достаточно конфигурирования. Начни с этого.

Настройки по умолчанию для паролей можно посмотреть тут:
https://docs.microsoft.com/ru-ru/aspnet/core/security/authentication/identity-configuration#password

Заодно в том же документе можно посмотреть настройки по умолчанию для входа:
https://docs.microsoft.com/ru-ru/aspnet/core/security/authentication/identity-configuration#sign-in

Чтобы облегчить себе жизнь во время прохождения блока:

1. Скопируй явную конфигурацию из документации в `IdentityHostingStartup.cs`
2. Выстави настройки для паролей `RequireDigit`, `RequireNonAlphanumeric`,
и `RequireUppercase` в `false`. Оставь `RequireLowercase` в `true`!
3. Также выстави в настройках входа `RequireConfirmedAccount` в `false`.
Убедись, что нигде в `IdentityHostingStartup.cs` больше `RequireConfirmedAccount` в `true` не выставляется.

В реальных проектах так делать не надо, это только для разработки и обучения :)

При желании можешь поменять пароли для `vicky`, `cristina` и `dev` в файле `DataExtensions.cs`, чтобы было проще.
Зарегистрируй нового пользователя с простым паролем из 6 символов: у тебя должно получиться.
Затем выйди из него и зайди снова. Вход должен получиться, несмотря на то, что ты не подтверждал email.

Все же может потребоваться добавить новые правила проверки паролей.
Например, проверить, что новый пароль не совпадает с логином пользователя.
Проверка уже реализована в `Services/UsernameAsPasswordValidator.cs`. Изучи ее код.
А затем добавь строчку `.AddPasswordValidator<UsernameAsPasswordValidator<PhotoAppUser>>()`
в конфигурировании `Identity` и убедись, что нельзя зарегистрировать пользователя, если пароль совпадает с email.


### 1.6. Алгоритм хэширования паролей

Может понадобится изменить алгоритм хэширования паролей. Например, если есть база пользователей,
которым надо дать доступ к приложению, но при их регистрации использовался свой собственный алгоритм хэширования.

Если использовалась предыдущая версия `Identity`, то алгоритм хэширования можно просто донастроить,
указав верную версию и количество итераций при хэшировании:
```cs
services.Configure<PasswordHasherOptions>(options =>
{
    options.CompatibilityMode = PasswordHasherCompatibilityMode.IdentityV3;
    options.IterationCount = 12000;
});
```

Полностью заменить алгоритм хэширования на свой можно так:
```cs
services.AddScoped<IPasswordHasher<PhotoAppUser>, SimplePasswordHasher<PhotoAppUser>>();
```

Вот только `SimplePasswordHasher` из папки `Services` не до конца реализован.
Имея реализацию метода `HashPassword`, дореализуй метод `VerifyHashedPassword`.
Чтобы убедиться, что реализация корректна, используй тесты на `SimplePasswordHasher`,
которые находятся в том же файле.

Затем подключи `SimplePasswordHasher`, с помощью Debug убедись, что теперь используется он,
а вход под пользователями с новым алгоритмом хэширования работает.


### 1.7. Локализация

Все ошибки, которые ты видел, были на английском языке. Это не очень удобно для русскоговорящих пользователей.

В большинстве случаев тексты ошибок на английском прописаны в файлах `Identity/Pages`.
Например, в файле `Register.cshtml.cs` в классе `InputModel` с помощью атрибутов.
У любого атрибута для валидации есть свойство `ErrorMessage`, в котором можно прописать текст сообщения об ошибке
на русском языке. Таким образом эти тексты ошибок легко локализуются.
Задай текст сообщения для атрибута `Required` в свойстве `Email` класса `InputModel`.

Но кроме атрибутов для локализации нужно поменять реализацию `IdentityErrorDescriber`.
Уже есть готовая реализация, позаимствованная со StackOverflow: `Services/RussianIdentityErrorDescriber.cs`.
В файле `IdentityHostingStartup.cs` в конфигурировании `Identity` (найди `services.AddDefaultIdentity<PhotoAppUser>()`)
добавь строчку `.AddErrorDescriber<RussianIdentityErrorDescriber>()`.

Теперь попробуй зарегистрировать нового пользователя:

- Сначала заполни email, а затем сделай пустым. Ты должен увидеть сообщение об ошибке из атрибута `Required`.
  Благодаря `jquery.validate` сообщение появляется до отправки формы.
- Теперь введи корректный email, но в качестве пароля используй 6 цифр, например, 123456.
  Отправь форму. Если все правильно, то в ответ получишь сообщение
  из `RussianIdentityErrorDescriber`: «Пароль должен содержать хотя бы один символ в нижнем регистре»

Как локализовать весь остальной пользовательский интерфейс ясно: надо локализовывать файлы из папки `Identity/Pages`.
Сейчас, по понятным причинам, этого делать не нужно.


## 2. Сессии

После успешной аутентификации информация о пользователе по умолчанию хранится в cookie.
Браузер постоянно передает эту cookie на сервер и за счет этого все действия пользователя можно авторизовать.


По умолчанию все работает некоторым образом. Настройки по умолчанию можно посмотреть тут:
https://docs.microsoft.com/ru-ru/aspnet/core/security/authentication/identity-configuration#cookie-settings

Давай донастроим. Для этого:

1. Скопируй явную конфигурацию из документации в `IdentityHostingStartup.cs`.
2. Выстави `options.Cookie.Name` значение `"PhotosApp.Auth"`, чтобы сессия хранилась в cookie с известным именем.
3. Обрати внимание на настройку `options.Cookie.HttpOnly = true`. Это значит, что cookie не будет доступна
клиентским скриптам, что обычно правильно и защищает пользователя от атак со скриптов.
4. Настройка `options.SlidingExpiration = true` означает, что сессия не протухнет,
пока пользователь активно использует приложение. Это тоже хорошее поведение.

Теперь залогинься под любым пользователем и найди в меню приложения ссылку на страницу Decode и перейди по ней.
На этой странице аутентификационная кука расшифровывается, а затем информация из нее выводится.
Ниже на странице выводится информация о пользователе из поля `User` контроллера, т.е. как ее видят контроллеры.
Видно, что сейчас в cookie и в `User` хранится одна и та же информация.


Посмотри `/Views/Shared/_IdentityDecodePartial.cshtml`, чтобы понять, как можно достать данные о пользователе
из cookie и из `User`. Запоминать тонкости реализации не нужно.

Стоит убедиться, что данные в cookie защищаются с помощью `IDataProtector`, реализацию которого можно задать.
В частности, чтобы cookie зашифровывались по некоторому алгоритму с известным серверу ключом при создании
и расшифровывались при использовании.

Также стоит разобраться с используемыми понятиями:

- Обрати внимание, что «пользователь» (`User`) может включать в себя несколько «личностей» (`Identities`).
Это нужно, потому что информация о пользователе может приходить из разных источников (cookie, headers и т.д.)
и может быть разной. В одном случае — это Вики, в другом — Скарлетт Йоханссон. И все личности — это один пользователь.
- Также обрати внимание, что при расшифровке cookie из нее достается `AuthenticationTicket`, т.е. «удостоверение».
«Удостоверение» хранит разную информацию и в частности свойство `Principal`.
«Приципал» — это лицо, от чьего имени может действовать предъявитель удостоверения.
В данном случае браузер, который отправил нашему сервису cookie.
- Наконец, еще одно понятие — claims. Это некоторые «утверждения» про «личность», представляющие из себя
пары ключ-значение. Например, «возраст = 72», «роль = режиссер», «гражданство = США».
На основании этих «утверждений» пользователю могут быть доступны те или иные действия в приложении.


Если надо хранить в сессии много данных о пользователе, то аутентификационная кука станет достаточно большой.
Неэкономично заставлять браузер передавать все эти данные с каждым запросом в виде cookie.
В этом случае можно хранить данные о сессии на сервере.

Для хранения сессии на сервере хорошо подойдет распределенной InMemory хранилище.
InMemory — для скорости, распределенное — для отказоустойчивости. Например, подойдет Redis.
Но для учебных целей воспользуемся все тем же Sqlite.

Готовые хранилища уже реализованы в `Services/EntityTicketStore.cs` и `Services/MemoryCacheTicketStore.cs`
Посмотри как они устроены.

`MemoryCacheTicketStore` проще, потому что хранит всю информацию о сессиях в оперативной памяти.
Это очень быстро, но перезагрузка веб-сервера заставит пользователей входить заново. Не надо так.

Поэтому подключать стоит `EntityTicketStore`, сделай это:
```cs
services.AddTransient<EntityTicketStore>();
services.ConfigureApplicationCookie(options =>
{
    var serviceProvider = services.BuildServiceProvider();
    options.SessionStore = serviceProvider.GetRequiredService<EntityTicketStore>();
    /* добавленный ранее код конфигурации */
});
```

Так как это хранилище использует Entity Framework Core, надо его сконфигурировать,
а затем выполнить миграцию и обновление базы данных:

1. Сконфигурируй `TicketsDbContext` в `IdentityHostingStartup.cs` аналогично `UsersDbContext`
2. Добавь значение для `TicketsDbContextConnection` в `appsettings.json`,
причем можешь снова использовать `PhotosApp.db` в качестве файла БД
3. `dotnet ef migrations add Tickets --context TicketsDbContext`
4. `dotnet ef database update --context TicketsDbContext`,
либо добавить `dbContext.Database.Migrate()` в `Data/DataExtensions.cs`
5. Вызови метод `SeedWithSampleTicketsAsync` в `Data/DataExtensions.cs`, передав туда `TicketsDbContext`,
чтобы зачищать все сессии перед стартом приложения. Пользователи каждый раз пересоздаются — значит
нет смысла хранить сессии.

После подключения снова залогинься и перейди на страницу Decode.
Обрати внимание, что теперь в аутентификационной куке хранится только идентификатор сессии.
Вся остальная информация о пользователе хранится и незаметно достается из Sqlite.


## 3. Роли и политики

### 3.1. Роли

Не весь функционал должен быть доступен каждому пользователю.
Требуется ограничить права различных групп пользователей.


Один из способов — ввести систему ролей.
Добавь новую роль `Dev`, присвой ее уже имеющемуся пользователю `dev@gmail.com` и сделай так,
чтобы только пользователи с ролью `Dev` имели доступ к `DevController`.

Подсказки:

- В конфигурировании `Identity` в `IdentityHostingStartup.cs` надо добавить `.AddRoles<IdentityRole>()`
сразу после `.AddDefaultIdentity<PhotoAppUser>()`
- Нужно создать Роль в БД. Код создания роли уже есть в методе `SeedWithSampleRolesAsync`.
Сделай так, чтобы метод `SeedWithSampleRolesAsync` из `DataExtensions.cs` выполнялся при создании БД,
т.е. в методе `PrepareDB`, причем до `SeedWithSampleUsersAsync`.
Тебе понадобится `RoleManager<IdentityRole>`: достань его из `ServiceProvider`.
- Добавить пользователю новую роль можно командой `await userManager.AddToRoleAsync(user, "RoleName")`
- Защитить метод или контроллер можно с помощью атрибута с параметром: `[Authorize(Roles = "RoleName")]`

Когда закончишь, убедись, что только пользователь `dev@gmail.com` может пользоваться страницей Decode,
а у других пользователей возникает сообщение об ошибке.


Будет хорошо, если пользователи, которым недоступен Decode вообще не будут видеть ссылку на страницу. Сделай так!
Проверить во view, что у текущего пользователя есть роль можно так: `User.IsInRole("RoleName")`


### 3.2. Политики

Более гибко настраивать права пользователей позволяют политики на основании различных claims (утверждений) пользователя.

Сейчас любому пользователю при заходе на страницу отдельной фотографии доступно изменение подписи к фотографии.
Сделай так, чтобы возможность редактировать подписи к фотографиям была доступна только beta-тестерам.

Для начала в `IdentityHostingStartup.cs` нужно зарегистрировать некоторую политику:
```cs
services.AddAuthorization(options =>
{
    options.AddPolicy(
        "Beta",
        policyBuilder =>
        {
            policyBuilder.RequireAuthenticatedUser();
            policyBuilder.RequireClaim("testing", "beta");
        });
});
```

Эта политика требует, чтобы пользователь был аутентифицирован и у него был claim `testing` со значением `beta`.
Сейчас таких пользователей нет.

Сделай так, чтобы при старте приложения пользователю `vicky` добавлялся такой claim.
Подсказка: `await userManager.AddClaimAsync(user, new Claim("claimType", "claimValue"))`
Claim, добавленные таким образом хранятся в отдельной таблице.
Можешь в этом убедиться с помощью https://sqliteonline.com/.

Теперь защити действие `EditPhoto` в `PhotoController` с помощью атрибута `[Authorize(Policy = "Beta")]`.


Когда закончишь, убедись, что только пользователь `vicky@gmail.com` может редактировать подписи к фотографиям,
а у других пользователей возникает сообщение об ошибке.


Будет хорошо, если пользовали, которым недоступно редактирование подписей вообще не видели ссылки на это действие.
Проверить во view выполнение политики для пользователя можно так:
```cshtml
(await AuthorizationService.AuthorizeAsync(User, "PolicyName")).Succeeded
```
Только надо добавить в начале view подключение зависимостей:
```cshtml
@using Microsoft.AspNetCore.Authorization
@inject IAuthorizationService AuthorizationService
```
Скрой действие «Изменить подпись» на странице отдельной фотографии.


Когда закончишь с этим добавь еще одну политику: пусть только платым пользователям будет доступна загрузка фотографий.
Назови политику `CanAddPhoto`, в качестве типа claim используй `subscription`, в качестве значения `paid`.
Аналогично предыдущей политике, защити методы `PhotoController` для загрузки фотографий.
и скрой ссылку «Добавить фото» в меню приложения. Также скрой ссылку на метод `AddPhoto` в `Index.cshtml`,
которая показывается, когда у пользователя нет фотографий.

А вот claim в пользователя надо выставить иначе. Путь он не хранится отдельно в таблице, а вычисляется по свойствам из `PhotoAppUser`.

Для этого:

1. Добавь в класс `PhotoAppUser` булево свойство `Paid`.
2. Создай миграцию, т.к. надо добавить новую колонку в таблицу пользователей:
`dotnet ef migrations add Paid --context UsersDbContext`
2. Разбери generic-параметр `TUser` в методе `SeedWithSampleUsersAsync`, заменив его использования
на тип `PhotoAppUser`.
3. Сделай так, чтобы пользователю `cristina` при создании в свойство `Paid` выставлялось значение `true`. 
4. Самое важное! Допиши класс `CustomClaimsPrincipalFactory`
в файле `Services/Authorization/CustomClaimsPrincipalFactory.cs`.
Сначала замени во всем файле использование `IdentityUser` на `PhotoAppUser`, 
а затем сделай так, чтобы пользователю с `Paid == true` выставлялся claim `subscription` со значением `paid`.
5. Зарегистрируй фабрику в `IdentityHostingStartup.cs` в конфигурации `Identity`,
добавив для этого вызов `.AddClaimsPrincipalFactory<CustomClaimsPrincipalFactory>()`
в цепочку вызовов после `.AddDefaultIdentity<PhotoAppUser>()`.

Убедись, что пользователю `cristina` доступно добавление фото, `vicky` не доступно.

Как видишь, определив собственную `UserClaimsPrincipalFactory`,
можно выставить пользователю нужные claims по произвольным правилам «на лету»,
т.е. без хранения самих claims в базе данных.


### 3.3. Обработчик для требования

В приложении до сих пор любой аутентифицировавшийся пользователь может открыть любую фотографию,
если у него будет прямая ссылка до нее.

Убедись в этом:

1. Зайди под пользователем `vicky`
2. Перейди на страницу с одной фотографией и сохрани URL страницы
3. Выполни logout и зайди под пользователем `cristina`
4. Используй сохраненный URL, чтобы открыть фотографию. Она доступна другому пользователю!

Чтобы создать политику, которая бы запрещала доступ к фото другим пользователям,
потребуется `AuthorizationHandler`.


Для начала создай новую политику `MustOwnPhoto`, а в ней потребуй два условия:
```cs
policyBuilder.RequireAuthenticatedUser();
policyBuilder.AddRequirements(new MustOwnPhotoRequirement());
```

`MustOwnPhotoRequirement` — некоторое требование, которое будет проверяться динамически с помощью обработчика.
Обработчик для этого требования уже добавлен. Это класс `MustOwnPhotoHandler`. Он может быть
обработчиком требования, потому что наследуется от класса `AuthorizationHandler<MustOwnPhotoRequirement>`.

Но, чтобы обработчик создавался его надо зарегистрировать в качестве `IAuthorizationHandler`:
```cs
services.AddScoped<IAuthorizationHandler, MustOwnPhotoHandler>();
```

Защити действия `GetPhoto`, `GetPhotoFile`, `EditPhoto`, `DeletePhoto` в `PhotoController` с помощью новой политики.
Заметь, что это нормально использовать несколько атрибутов `Authorize` у метода.
В этом случае для выполнения действия должны быть выполнены требования каждого атрибута.

Допиши `MustOwnPhotoHandler` так, чтобы требование выполнялось,
если текущий пользователь является владельцем фотографии.


## 4. Аутентификация через Google

ASP.NET Core включает встроенную поддержку для OAuth, за счет чего к нему
легко подключить внешних провайдеров аутентификации.
А для некоторых, включай Google и Facebook есть даже готовые методы,
позволяющие подключить провайдера, написав пару строчек.

Добавь следующий код в `IdentityHostingStartup.cs`:
```cs
services.AddAuthentication()
    .AddGoogle("Google", options =>
        {
            options.ClientId = context.Configuration["Authentication:Google:ClientId"];
            options.ClientSecret = context.Configuration["Authentication:Google:ClientSecret"];
        });
```
Это почти все, что нужно, чтобы заработала аутентификация через Google в случае `Identity`,
потому что отображение нужных кнопок для внешних провайдеров аутентификации уже реализовано.


Осталось только зарегистрировать приложение в Google, получить Client ID и Client Secret,
а затем положить их в настройки, чтобы следующие строчки работали корректно:
```cs
options.ClientId = configuration["Authentication:Google:ClientId"];
options.ClientSecret = configuration["Authentication:Google:ClientSecret"];
```

Для этого:

1. Перейди на страницу https://developers.google.com/identity/sign-in/web/sign-in#before_you_begin
2. Нажми кнопку «Configure Project»
3. Введи имя нового проекта
4. Выбери опцию Web server и введи https://localhost:7001/signin-google в качестве «Authorized redirect URIs».
5. Нажми на кнопку «Create», а затем получи Client ID и Client Secret

`/signin-google` — это путь, по которому Google отправит данные пользователя
после успешной аутентификации. Такой адрес используется по умолчанию в ASP.NET Core, соответственно,
данные от Google будут успешно получены и обработаны Authentication Middleware.


Client ID и Client Secret используются авторизации приложения в Google.
Их можно сохранить в `appsettings.json`, по ключам `Authentication:Google:ClientId`
и `Authentication:Google:ClientSecret` и все будет работать.
Но файлы, хранящиеся в репозитории, в том числе `appsettings.json` — это плохое место для хранения паролей и секретов.

Поэтому лучше воспользоваться специальным хранилищем для секретов вот так:
```
dotnet user-secrets set "Authentication:Google:ClientId" "<client id>"
dotnet user-secrets set "Authentication:Google:ClientSecret" "<client secret>"
```

В этом случае значения будут сохранены тут:
- `%APPDATA%\Microsoft\UserSecrets\<user_secrets_id>\secrets.json` в Windows
- `~/.microsoft/usersecrets/<user_secrets_id>/secrets.json` в Linux, Mac

В Visual Studio секретами можно управлять, если кликнуть правой кнопкой мыши по проекту в «Solution Explorer»
и выбрать пункт «Manage Secrets».

После сохранения реквизитов в хранилище для секретов не обязательно их удалять из `appsettings.json`,
потому что значения из хранилища более приоритетны и перетрут значения из `appsettings.json`.


Далее своими проектами в Google можно будет управлять через специальный «пульт»:
https://console.developers.google.com/apis/credentials


После верного задания Client ID и Client Secret аутентификация через Google
должна появиться на странице логина и корректно работать.


## 5. Письма

Хорошая практика — предлагать пользователю подтвердить адрес своей электронной почты,
чтобы случайная опечатка при вводе email или забытый пароль не приводили к потере доступа к аккаунту.

`Identity` пытается отправлять письма с кодом подтверждения всем новым пользователям с помощью `IEmailSender`.
По умолчанию он реализован так, что ничего не отправляет.


В `Services/SimpleEmailSender` есть реализация, которая умеет отправлять письма через внешний SMTP-сервер.
Подключи ее:
```cs
services.AddTransient<IEmailSender, SimpleEmailSender>(serviceProvider =>
    new SimpleEmailSender(
        serviceProvider.GetRequiredService<ILogger<SimpleEmailSender>>(),
        serviceProvider.GetRequiredService<IWebHostEnvironment>(),
        context.Configuration["SimpleEmailSender:Host"],
        context.Configuration.GetValue<int>("SimpleEmailSender:Port"),
        context.Configuration.GetValue<bool>("SimpleEmailSender:EnableSSL"),
        context.Configuration["SimpleEmailSender:UserName"],
        context.Configuration["SimpleEmailSender:Password"]
    ));
```
Большинство настроек для подключения к SMTP-серверу Google уже прописаны в `appsettings.json`.
Пропиши в файл или в User Secrets адрес своей электронной почты Google в `UserName`
и соответствуйщий пароль в `Password`.

Также, чтобы «стороннее приложение», которое ты пишешь, смогло отправлять письма придется
понизить уровень безопасности аккаунта на странице https://myaccount.google.com/lesssecureapps

Зарегистрируй нового пользователя с существующим email и убедись, что на него пришло письмо
для подтверждения адреса электронной почты.


Если нужно, чтобы без подтверждения email нельзя было войти в аккаунт,
следует изменить настройку `SignIn.RequireConfirmedEmail` для `Identity`.
Но в обучающем проекте нам это не нужно.


Хоть подтвреждение почты является важной частью регистрации, в дальнейших заданиях она не понадобится.
Поэтому можно вернуть обратна настройки безопасности аккаунта Google: https://myaccount.google.com/lesssecureapps
А для настроек `UserName` и `Password` задай пустые строки в качестве значений.


## 6. Json Web Token и схемы аутентификации

Сейчас тебе предстоит добавить нестандартный способ аутентификации в сервисе.
Работать он должен так: пользователь переходит по секретному URL, где ему выставляется cookie с JWT-токеном.
Этот короткоживущий токен дает доступ разработчика к сервису на полминуты.


Найди и открой `HackController`. В методе `GenerateToken` с суперсекретным адресом вызывается генерация JWT-токена.
Затем этот токен добавляется в cookie.

Для начала надо доработать генерацию токена в методе `TemporaryTokens.GenerateEncoded`.

1. Сделай так, чтобы токен не действовал до текущего момента.
Для этого надо передать текущее время в UTC в `notBefore`.
2. Сделай так, чтобы токен действовал всего лишь 30 секунд, задав правильно `expires`.
3. Заполни `claims`:
    - Утверждению `ClaimTypes.NameIdentifier` (идентификатор пользователя) задай значение `Guid.NewGuid().ToString()`
    - Утверждению `ClaimsIdentity.DefaultNameClaimType` (имя пользователя) задай какое-нибудь значение
    - Утверждению `ClaimsIdentity.DefaultRoleClaimType` (роль пользователя) задай значение `"Dev"`
4. Чтобы токен нельзя было подделать можно добавить зашифрованный с помощью симметричного ключа отпечаток.
В этом случае получатель токена, если у него есть ключ шифрования, сможет построить свои отпечаток
и сравнить с отпечатком, добавленным издателем. Если отпечатки не совпадут, значит токен поддельный.
Воспользуйся алгоритмом HMAC SHA-256.
SHA-256 — хэш-функция, HMAC — алгоритм, использующий симметричный ключ и некоторую хэш-функцию для получения отпечатка.
Все уже реализовано, надо только правильно задать `signingCredentials`.
Используй ключ из свойства `TemporaryTokens.SigningKey`, а имя алгоритма есть в константе `SecurityAlgorithms.HmacSha256`.

Теперь, если обратиться по пути `/hack/super_secret_qwe123` будет возвращен токен. Он также окажется в cookie.

Получи и расшифруй этот токен с помощью сервиса https://jwt.io/.
Передай зашифрованный вариант и убедись, что в «PAYLOAD» там заданные тобой данные.

Добейся того, чтобы появилась надпись «Signature Verified».
Алгоритм подписи должен автоматически выставиться в HS256, т.к. он передается в заголовке токена,
так что осталось передать правильный ключ симметричного шифрования в блоке «VERIFY SIGNATURE».


Итак, правильный JWT-токен уже можно получить в виде cookie.
Но пока приложение никак на это не реагирует. Надо это исправить.

Добавь следующий код в `IdentityHostingStartup.cs`:
```cs
services.AddAuthentication()
    .AddJwtBearer(options =>
    {
        options.RequireHttpsMetadata = false;
        options.TokenValidationParameters = new TokenValidationParameters
        {
        };
    });
```
После этого аутентификация по JWT-токены в какой-то степени начнет поддерживаться. Но надо донастроить.

В `TokenValidationParameters`:

1. Выстави `ValidateIssuer` и `ValidateAudience` в `false`,
потому что информация об издателе и получателях токена не добавлялась.
2. Выстави `ValidateLifetime` в `true`, чтобы старые токены не работали.
Также задай `ClockSkew = TimeSpan.Zero`. Дело в том, что токены генерируются и проверяются обычно на разных серверах
и время на них может отличаться. Поэтому при проверке токенов допускается погрешность в несколько минут.
Это правильно, но для корректной работы токена с временем жизни в полминуты нужно от погрешности отказаться.
3. Выстави `ValidateIssuerSigningKey` в `true`, чтобы проверялся отпечаток токена.
В `IssuerSigningKey` передай использованный при создании отпечатка ключ.

Еще один нюанс — откуда будет доставаться токен.
Обычно JWT-токены передаются в заголовке `Authorization` и подписью `Bearer`, которая указывает,
что авторизация будет с помощью токена «на предъявителя».
Выглядит это примерно так:
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.Et9HFtf9R3GEMA0IICOfFMVXY7kkTX1wr4qCyhIf58U
```

*Замечание. Другим распространенным способом авторизации является Basic, в которой в заголовке Authorization*
*передается подпись Basic, после чего идет строка логин:пароль (например, aladdin:opensesame),*
*закодированная с помощью base64.*
*Выглядит это примерно так:*
```
Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
```

Сейчас же токен хранится в cookie. Но можно подсказать ASP.NET Core откуда брать токен вот так:
```cs
options.Events = new JwtBearerEvents
{
    OnMessageReceived = c =>
    {
        c.Token = c.Request.Cookies["NameOfCookieWithToken"];
        return Task.CompletedTask;
    }
};
```
Только не забудь передать правильное имя cookie.


Аутентификация по JWT-токенам теперь должна работать.

Проверь, что токен правильно генерируется и преобразуется в `User`:

1. Перейди по секретному адресу `/hack/super_secret_qwe123` и получи токен.
2. Перейди на секретную страницу декодирования пользователя `/hack/decode`,
которая требует авторизацию токеном и убедись, что пользователь заполнен.


Пора настроить авторизацию. Сейчас она настроена использовать только `Identity`.
Надо сделать так, чтобы авторизация поддерживала оба способа аутентификации: `Identity` и `JwtBearer`.

Сначала немного теории. У каждого способа аутентификации есть идентификатор — схема.
`Identity` использует сразу несколько схем. Название основной схемы хранится
в константе `IdentityConstants.ApplicationScheme` и равно `"Identity.Application"`.
Также в `Identity` используется схема `"Identity.External"` для внешних провайдеров, например, Google.
Для `JwtBearer` значение схемы по умолчанию хранится в константе `JwtBearerDefaults.AuthenticationScheme`
и равно `"Bearer"`.
Если надо добавить поддержку нескольких видов `JwtBearer`, то можно задать схему явно:
```cs
services.AddAuthentication()
    .AddJwtBearer("SomeJWT", options => { /* */ })
    .AddJwtBearer("AnotherJWT", options => { /* */ });
```

`Identity` тоже добавляет свой способ аутентификации при вызове `services.AddDefaultIdentity<PhotoAppUser>()`.
В `AddDefaultIdentity` скрыт следующий код:
```cs
services.AddAuthentication(o =>
{
    o.DefaultScheme = IdentityConstants.ApplicationScheme;
    o.DefaultSignInScheme = IdentityConstants.ExternalScheme;
}).AddIdentityCookies();
```
`AddIdentityCookies` — это добавляемый способ аутентификации.
А настройка `DefaultScheme` — это та схема, которая будет использоваться по умолчанию для различных операций.
В том числе атрибутом `[Authorize]`. И `AddDefaultIdentity` выставляет `Identity` для использования по умолчанию.


`Identity` в качестве схемы по умолчанию — это нормально, пусть так и будет.
А надо сделать так, чтобы `[Authorize]` стал поддерживать новый способ аутентификации.
Для этого надо переопределить политику авторизации по умолчанию вот так:
```cs
services.AddAuthorization(options =>
{
    options.DefaultPolicy = new AuthorizationPolicyBuilder(
        JwtBearerDefaults.AuthenticationScheme,
        IdentityConstants.ApplicationScheme)
        .RequireAuthenticatedUser()
        .Build();
        /* добавленный ранее код конфигурации */
}
```
Новая политика использует и `Identity`, и `JwtBearer`.


Пришло время для проверки:

1. Перейди по секретному адресу `/hack/super_secret_qwe123` и получи токен.
2. Перейди на главную страницу и убедись, что доступна ссылка «Decode», как и всем разработчикам.
3. Перейди по ней и убедись, что сам метод пока еще не доступен.


Настройка политики по умолчанию никак не влияет на атрибуты с дополнительными настройками,
в том числе на `[Authorize(Roles = "Dev")]`, поэтому страница по ссылка «Decode» еще не работает.

Быстрый способ починить — дополнительно к роли перечислить в атрибуте допустимые схемы через запятую:
```cs
[Authorize(Roles = "Dev", AuthenticationSchemes = "Bearer, Identity.Application")]
```
Но так делать сейчас не надо.

Качественный способ решить эту проблему — везде для конфигурирования авторизации использовать политики,
как ранее использовали `[Authorize(Policy = "Beta")]`. Глядя на политику по умолчанию и другие политики,
добавь политику `"Dev"`. Тебе пригодятся методы `RequireRole` и `AddAuthenticationSchemes` у `policyBuilder`.
Для корректной работы этой политики надо добавить обе схемы: `JwtBearerDefaults.AuthenticationScheme`
и `IdentityConstants.ApplicationScheme`. Причем именно в таком порядке! Объяснения почему будет немного позже.

Как добавишь политику — используй ее! Во-первых, в `DevController`, поправив атрибут `Authorize`.
Во-вторых, при показе ссылки «Decode» в `_Layout.cshtml`, сделав аналогично показу ссылки «Добавить фото».
После этого ссылка «Decode» должна заработать.
Причем как для аутентификации по токену, так и для пользователя `dev@gmail.com`.


Итоговая проверка:

1. Перейди по секретному адресу `/hack/super_secret_qwe123` и получи токен.
2. Залогинься под пользователем `vicky@gmail.com`.
3. Перейди на главную страницу и убедись, что отображаются фотографии пользователя `vicky@gmail.com`.
4. Убедись, что в качестве имени пользователя в правом верхнем углу главной страницы отображается `vicky@gmail.com`.
5. Убедись, что доступна ссылка «Decode», как и всем разработчикам.
6. Перейди по ссылке «Decode» и убедись, что пользователь (ClaimsPrincipal) представлен
двумя личностями (ClaimsIdentity), одна из которых заполнена из токена, а другая — `vicky@gmail.com`.
7. Убедись, что в качестве имени пользователя в правом верхнем углу страницы «Decode» отображается `vicky@gmail.com`.


А теперь еще немного теории про схемы аутентификации и политики авторизации.

При аутентификации в `UseAuthentication` создается единственная `Identity` с использованием схемы по-умолчанию.
Далее создается `Principal`, который содержит эту `Identity`, и сохраняется в `User`.
При этом у `Principal` доступно свойство `Claims`, значение которого определяется `Claims`
из этой единственной `Identity`. Затем эти `Claims` используются для авторизации.

Одним предложением: по схеме по-умолчанию создается `Identity`, а затем используется при авторизации.

Но в этом случае, если какие-то claims надо взять из куки у схемы `"Identity.Application"`,
а другие из токена у схемы `"Bearer"`, авторизация работать не будет. Потому что `Identity` строится
с использованием одной схемы: схемы по-умолчанию.

Поэтому, если согласно политики для авторизации конкретного запроса требуется несколько схем,
`User`, построенный в `UseAuthentication`, переопределяется в `UseAuthorization`.
При этом для каждой схемы строится своя `Identity`, все они добавляются в `Principal`, который и сохраняется в `User`,
а затем используется для авторизации.

Но остается нюанс: а что если один и тот же claim, например, `name`, определен сразу в нескольких `Identity`?
Какое имя будет у пользователя? Ответ: claim из схемы, которая указана позже в определении политики,
будут более приоритетны.

Например, пусть в схеме `"Bearer"` у пользователя имя `Temporary Dev`, а в схеме `"Identity.Application"` — `vicky@gmail.com`.
При использовании в политике следующего кода у пользователя будет имя `vicky@gmail.com`:
```cs
policyBuilder.AddAuthenticationSchemes("Bearer", "Identity.Application")
```
А при использовании такого кода у пользователя будет имя `Temporary Dev`:
```cs
policyBuilder.AddAuthenticationSchemes("Identity.Application", "Bearer")
```

При этом не должно смущать слово `First` в коде `User.FindFirstValue(ClaimTypes.NameIdentifier)`, который можно прочесть как
«найди у пользователя первый claim с типом `nameidentifier`». Просто чем ПОЗЖЕ идет схема в определении политики,
тем РАНЬШЕ находится `Identity` этой схемы в `Principal`, т.е. в `User`.

Одним предложением: для каждой схемы из политики создается `Identity` и при авторизации используются они все,
но схемы, идущие позже, более приоритетны.


Чтобы убедиться, что это работает именно так, можно посмотреть исходники ASP.NET Core на GitHub:
- Про аутентификацию в [AuthenticationMiddleware](https://github.com/dotnet/aspnetcore/blob/master/src/Security/Authentication/Core/src/AuthenticationMiddleware.cs)
- Про авторизацию в [AuthorizationMiddleware](https://github.com/dotnet/aspnetcore/blob/master/src/Security/Authorization/Policy/src/AuthorizationMiddleware.cs)

*Замечание. Исходники на GitHub позволяют раскрыть многие нюансы работы ASP.NET Core,*
*причем, в отличие от документации или статей, говорят правду и полностью.*
*Более того, архитектура ASP.NET Core позволяет легко переопределять и расширять функциональность,*
*и, как следствие, нужные исходники можно не только посмотреть и скачать,*
*но и подключить, и отладить прямо в своем приложении. Отладка же позволяет сорвать все покровы.*
*Искать исходники достаточно удобно с помощью Google: в запросе надо написать имя класса,*
*иногда namespace, а также слово github и, возможно, asp.net core.*
*Например, "AuthenticationMiddleware asp.net core github".*
*Если же искать приходится часто, то репозиторий с ASP.NET Core можно просто склонировать:*
`git clone https://github.com/dotnet/aspnetcore`


А теперь для закрепления материала проведи несколько экспериментов:

1. Запусти приложение, аутентифицируйся под пользователем `vicky@gmail.com` и с помощью `/hack/super_secret_qwe123`,
т.е. по обеим схемам. Перейди на страницу «Decode» и проверь порядок `Identity` в `User`.
Первой должна идти `Identity` для схемы `"Identity.Application"`.

2. В политике `Dev` поменяй местами схемы, чтобы `JwtBearerDefaults.AuthenticationScheme` была последней.
То же самое сделай для `DefaultPolicy`. Запусти приложение, аутентифицируйся по обеим схемами.
Обрати внимание на имя пользователя на главной странице стало `Temporary Dev`.
Перейди на страницу «Decode» и убедись, что порядок `Identity` в `User` тоже поменялся.
Обрати внимание, что имя пользователя на странице «Dev» тоже стало `Temporary Dev`.

3. Верни исходный порядок схем в политике `DefaultPolicy`. Запусти приложение, аутентифицируйся по обеим схемами.
Обрати внимание, что ссылка «Decode» на главной странице доступна, а имя пользователя — `vicky@gmail.com`.
Перейди на страницу «Decode» и обрати внимание, что имя пользователя отличается, т.е. `Temporary Dev`.

4. А теперь закомментируй в политике `Dev` добавление разных схем, т.е. `policyBuilder.AddAuthenticationSchemes`.
Запусти приложение, аутентифицируйся по обеим схемам. Обрати внимание, что ссылка «Decode»
на главной странице доступна. Перейди по ней и убедись, что доступ к странице запрещен.

5. Раскоментируй `policyBuilder.AddAuthenticationSchemes` в политике `Dev` и убери добавление схем в `DefaultPolicy`.
Запусти приложение, аутентифицируйся по обеим схемам. Обрати внимание, что ссылка «Decode» исчезла с главной страницы.
Переди напрямую на странцу `/Dev/Decode`: она будет доступна и на ней будет ссылка «Decode».

6. Верни все, как было.

Полагаю, что с пунктами 1, 2 и 3 все понятно: на каждой странице действует некоторая политика и используется
тот порядок `Identity`, который соответствует добавлению схем в этой политике.

А вот пункт 4 не так очевиден. На первый взгляд, страница «Decode» недоступна, потому что схему
`JwtBearerDefaults.AuthenticationScheme` в политику не добавили. То, что схема `JwtBearerDefaults.AuthenticationScheme`
при этом добавлена в `DefaultPolicy` значения не имеет.
Хорошо. Но тогда почему доступна ссылка «Decode» на главной странице? Все потому, что на главной странице в `User`
находятся `Identity` для обеих схем, как это указано в `DefaultPolicy`, а значит пользователь аутентифицирован
и у него есть роль `Dev`. Ограничения политики `Dev` выполняются, пусть даже для этого использована «лишняя» схема.

Обратная ситуация в пункте 5. Было бы логично, чтобы ссылка на страницу «Decode» была доступна на главной.
Но нет. На главной странице основная политика — `DefaultPolicy`, в которой в этом пункте подключена только одна схема.
Поэтому в `User` находится только одна `Identity`, а значит у пользователя него нет роли `Dev`.

В пунктах 4 и 5 поведение немного странное. Может быть оно изменится в будущем, но пока оно такое и соответствует исходникам.

Вывод: чтобы не получать странные спецэффекты, во всех политиках стоит использовать один и тот же набор схем аутентификации.


## 7. Авторизация в другом сервисе с помощью Client Credentials Flow

До сих пор бэкенд веб-приложения работал в рамках одного веб-сервера. В реальных веб-приложениях это обычно не так.
Чаще всего есть некое веб-приложение, который отдает HTML-странички со скриптами и стилями, а большинство работы
выполняется отдельными веб-сервисами. Такие веб-сервисы обычно находятся отдельно от веб-приложения: на другой виртуалке,
на другой физической машине или даже в другом дата-центре.

*Замечание. Не вдаваясь в четкое определение понятия «веб-приложение», здесь и далее под этим термином*
*будет подразумеваться только веб-сервер, в котором выполняется программа, непосредственно взаимодействующая*
*с браузером пользователя: отдающая разметку, стили, скрипты и предоставляющие API для скриптов.*
*В нашем случае это PhotosApp.*
 
Из-за разделения на веб-приложения и веб-сервисы возникает вопрос: как защитить веб-сервисы от запросов от злоумышленников
и дать доступ своим веб-приложениям? Понятно, что в том или ином виде нужна авторизация для собственных веб-приложений.

Один из способов — использовать API-ключи. Разработчики веб-сервиса некоторым образом передают
разработчикам веб-приложения API-ключи, каждый из которых представляет собой уникальную строку.
А затем при запросах от веб-приложения к веб-сервису передается подходящий API-ключ.
Веб-сервис обнаруживает API-ключ в запросе и, если ключ еще действует, выполняет запрос.


Более продвинутый способ — использовать Client Credentials Flow протокола авторизации OAuth.

В этом случае кроме приложения и сервиса появляется еще одна сторона — сервер авторизации. Приложение регистрируется
в качестве клиента в сервере авторизации. А сервер авторизации затем выдает правильным клиентам правильные права.
Сервис тоже регистрируется в сервере авторизации, но в качестве ресурса. Сервис не получает каких-либо реквизитов,
но по сути обязуется доверять решениям сервера авторизации.

При регистрации приложению выдается client id и password. При необходимости доступа к ресурсам,
приложение предъявляет эти реквизиты серверу авторизации и запрашивает доступ к некоторому
множеству ресурсов, т.е. сервисов. Если сервер авторизации согласен, то выдает некий «токен»,
который приложение может использовать для доступа к запрошенным ресурсам.

Токен похож на API-ключ, но между двумя схемами есть отличия:

- В случае OAuth реквизиты клиента передаются только между клиентом и сервером авторизации.
Между приложением и сервисом передаются только токены.
- Токен обычно живет недолго, поэтому его потеря не так критична. API-ключи надо отзывать и получать заново.
- Сервер авторизации становится единым удобным местом настройки прав доступа между приложениями и сервисами.
Причем создать новую связь между зарегистрированным приложением и зарегистрированным сервисом легко.


Далее выделим `PhotosService` из `PhotosApp` и добавим между ними авторизацию по Client Credentials Flow.


### 7.1. Запуск отдельных сервисов

В этом задании понадобится запускать не только `PhotosApp`, но и `PhotosService`, и `IdentityServer`.

`PhotosService` — это сервис для хранения фотографий. Этот сервис реализует API, которое можно посмотреть
в `PhotosApiController`. Делать запросы к этому API из `PhotosApp` можно с помощью `RemotePhotosRepository`.
Это одна из реализаций `IPhotosRepository`, но в отличие от `LocalPhotosRepository`, который сейчас используется
в `PhotosApp`, она не достает фотографии с диска, а делает HTTP-запросы к `PhotosService`.
Сам `PhotoService` устроен максимально просто: получает HTTP-запросы и делегирует их выполнение
своему `LocalPhotosRepository`. Который, в свою очередь, хранит данные также,
как они сейчас хранятся в `PhotosApp`: информация в Sqlite, а файлы фотографий — в папк `.photos`.

`IdentityServer` — это реализация сервера авторизации, причем реализация «по-умолчанию».
Дело в том, что для .NET Core есть хорошая реализация сервера авторизации с OAuth и OpenIDConnect — `IdentityServer4`.
И, чтобы получить свой собственный сервер авторизации достаточно выполнить такие простые команды:
```
dotnet new -i IdentityServer4.Templates
dotnet new is4empty -n IdentityServer
dotnet sln add IdentityServer\IdentityServer.csproj
```
Первая команда подключает новые шаблоны для инструмента `new`, вторая создает пустой IdentityServer,
а последняя подключает ее в solution. Для получения проекта `IdentityServer` были выполнены эти 3 команды,
а также внутрь было добавлено логирование запросов с помощью middleware `UseSerilogRequestLogging`.

Это все, что было сделано, но уже получился рабочий сервер авторизации, который в перспективе можно подключить к СУБД,
добавить к нему UI и Identity, сконфигурировать так, как требуется. Хорошая архитектура с использованием
Dependecy Inversion Principle, а также открытые исходные коды позволяют легко дополнять или переопределять функционал
IdentityServer и делают его прекрасной основой для сервера авторизации на .NET Core.

Задания будут сфокусированы на использовании сервера авторизации, а не на его настройке.
Но если понадобится настроить, то можно использовать [документацию](https://identityserver4.readthedocs.io),
более полные шаблоны для `dotnet new`: `is4aspid` с ASP.NET Core Identity и `is4ef` с Entity Framework Core,
а также [исходные коды на GitHub](https://github.com/IdentityServer/IdentityServer4).


Как же все эти сервисы запускать? Один из вариантов — все в IDE. Например, все запускать под отладкой в Rider,
или в VS Code, или один какой-то сервис в Visual Studio, а другие два — в VS Code.

Но в целом достаточно будет под отладкой запускать какой-то один из сервисов, обычно `PhotosApp`,
а остальные — просто через консоль.

Команды для запуска через консоль:

- PhotosApp: `dotnet run --project PhotosApp`
- PhotosService: `dotnet run --project PhotosService`
- IdentityServer: `dotnet run --project IdentityServer`

Для Windows в корне репозитория можно найти и использовать следующие файлы: `launchPhotosApp.cmd`,
`launchPhotosService.cmd`, `launchIdentityServer.cmd`.

При любом варианте запуска у сервисов будут следующие адреса:
- PhotosApp: `https://localhost:5001`
- PhotosService: `https://localhost:6001`
- IdentityServer: `https://localhost:7001`


Произведи тестовый запуск:

1. В `PhotosApp` в `Startup.cs` замени использование локального репозитория на удаленный.
Для этого закомментируй строчку с подключением `LocalPhotosRepository` и добавь строчку
с подключением `RemotePhotosRepository`:
```cs
// services.AddScoped<IPhotosRepository, LocalPhotosRepository>();
services.AddScoped<IPhotosRepository, RemotePhotosRepository>();
```

2. Запусти любым способом `PhotosApp` и убедись, что при открытии страницы в `RemotePhotosRepository`
выбрасывается исключение.

3. Запусти любым способом `PhotosService`, обнови страницу в браузере. траница должна загрузиться,
но без фотографий. Войди под `vicky@gmail.com` и убедись, что ее фотографии подгрузились.

4. Запусти любым способом `IdentityServer` и убедись, что он запускается.


### 7.2. Client Credentials Flow

Для начала добавь аутентификацию по токену в `PhotosService`.

1. Добавь в метод `ConfigureServices` в `Startup.cs` в проекте `PhotosService` следующий код:
```
services.AddAuthentication("Bearer")
    .AddJwtBearer("Bearer", options =>
    {
        options.Authority = "https://localhost:7001";
        options.Audience = "photos_service";
    });
```
В нем добавляется аутентификация по токену, причем будут приниматься только токены, которые изданы и подписаны
сервером авторизации https://localhost:7001. А еще в этих токенах должно быть указано, что они дают доступ
к ресурсу `"photos_service"`. `PhotosService` как раз и будет этим «ресурсом».

2. Добавь middleware для аутентификации и авторизации между `UseRouting` и `UseEndpoints`:
```cs
app.UseAuthentication();
app.UseAuthorization();
```

3. Добавь атрибут `[Authorize]` контроллеру `PhotosApiController`.

Теперь запусти `PhotosApp` и `PhotosService`, зайди в приложение под `vicky@gmail.com` и убедись,
что фотографии не загружаются, а вместо них надпись «Ничего не найдено».
Да, `RemoteRepository` написан так, чтобы не падать, если доступ к фотографиям запрещен.


Далее надо зарегистрировать новый тип ресурсов в сервере авторизации.

Сейчас все ресурсы, доступ к которым можно получить через `IdentityServer`, перечислены в файле `Config.cs`.
То, что используется именно это файл, сконфигурировано в `Startup.cs` в `IdentityServer`.

Итак, в файле `Config.cs` найди статическое свойство `Apis` и добавь туда запись о новом ресурсе:
```cs
new ApiResource("photos_service", "Сервис фотографий")
```
Запись, которая там была в качестве примера, можно удалить.


Далее надо настроить, каким приложениям будет выдаваться доступ к новому ресурсу.

В файле `Config.cs` найди статическое свойство `Clients` и добавь туда запись о новом клиенте:
```cs
new Client
{
    ClientId = "Photos App by OAuth",
    ClientSecrets =
    {
        new Secret("secret".Sha256())
    },

    AllowedGrantTypes = GrantTypes.ClientCredentials,
    AllowedScopes = { "photos_service" }
}
```
Запись, которая там была в качестве примера, можно удалить.

В добавленной записи задается идентификатор и секрет клиента, используя которые приложение `PhotosApp` будет обращаться
к серверу авторизации, описано, что общение между приложением и сервером будет по Client Credential Flow,
а также описано, что при желании приложение сможет получить токен с доступом к ресурсу `"photos_service"`.


Теперь осталось только сконфигурировать приложение `PhotosApp`.

1. Выполни в папке с solution:
```
dotnet add PhotosApp package IdentityModel
```
`IdentityModel` позволяет делать различные запросы по протоколам OAuth и OpenID Connect.

2. Используя эту болванку, добавь метод `GetAccessTokenByClientCredentialsAsync` в `RemotePhotosRepository`,
который должен получать токен для `PhotosService` от `IdentityServer`:
```cs
private static async Task<string> GetAccessTokenByClientCredentialsAsync()
{
    var httpClient = new HttpClient();
    // NOTE: Получение информации о сервере авторизации, в частности, адреса token endpoint.
    var disco = await httpClient.GetDiscoveryDocumentAsync("TODO: адрес сервера авторизации");
    if (disco.IsError)
        throw new Exception(disco.Error);

    // NOTE: Получение access token по реквизитам клиента
    var tokenResponse = await httpClient.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest
    {
        Address = disco.TokenEndpoint,
        ClientId = "TODO",
        ClientSecret = "TODO",
        Scope = "TODO: необходимые ресурсы через пробел"
    });

    if (tokenResponse.IsError)
        throw new Exception(disco.Error);

    return tokenResponse.AccessToken;
}
```

3. В методе `SendAsync` в `RemotePhotosRepository`, который отправляет все запросы к `PhotosService`,
добавь получение access token с помощью метода `GetAccessTokenByClientCredentialsAsync`.
Полученный access token надо добавить в `httpClient`, чтобы все запросы отправлялись с токеном
в заголовке `Authorization` вот так:
```cs
httpClient.SetBearerToken(accessToken);
```


Теперь на каждый запрос к `PhotosService` приложение `PhotosApp` будет получать access token от `IdentityServer`
и отправлять его в запросе. А `PhotosService` будет проверять полученный access token и предоставлять доступ,
т.к. доверяет токенам от `IdentityServer`.

Убедись, что фотографии `vicky` снова отображаются после входа в `PhotosApp`.


### 7.3 Проверка токена

Как же `PhotosService` проверяет, что пришедшим ему токенам можно доверять?
Просто. Он идет по адресу из `options.Authority`, в нашем случае это https://localhost:7001, получает открытый ключ
и проверяет подпись токена. Кроме этого он проверяет, что время действия токена не прошло и что `options.Audience`,
в нашем случае `"photos_service"`, есть среди scope токена.

Проверь токен вручную!

Для этого поставь точку останова сразу после получения access token в методе `SendAsync`, запусти `PhotosApp`
под отладкой и получи содержимое токена. Это содержимое вставь в качестве токена в сервис https://jwt.io/.
Токен будет расшифрован и можно будет убедиться, что в нем есть значение `"photos_service"` в массиве `scope`,
а также, что токен выдан на 1 час (сравни значения в `exp` и `nbf`).

Осталось проверить подпись:

1. Перейди по адресу https://localhost:7001/.well-known/openid-configuration и увидишь подробную информацию
о сервере авторизации. Именно эта информация получается в запросе `GetDiscoveryDocumentAsync`.
Там есть адреса разных endpoints, но сейчас интересен адрес `jwks_uri` — перейди по нему.

2. JWK — это Json Web Key. И по адресу из `jwks_uri` ты увидишь массив публичных ключей сервера авторизации в формате JSON.
В нашем случае он будет включать только один ключ. У ключа будут
`kid`, т.е. key identifier — это идентификатор ключа. Этот идентификатор также есть в header токена,
чтобы было понятно с каким ключом проверять подпись.
`alg` — это алгоритм шифрования, с которым можно использовать этот ключ. Этот алгоритм тоже указывается в header токена.
`e` и `n` — это числа, образующие открытый ключ в [RSA](https://ru.wikipedia.org/wiki/RSA).
Открой исходный код страницы, чтобы плагины в твоем браузере не мешали, и скопируй ключ в буфер обмена.
Полностью весь объект, а не только `e` и `n`!

3. Вставь скопированный JWK в поле для public key в сервисе https://jwt.io/.
После этого должна появиться надпись «Signature Verified».

Ура, токен проверен!


## 8. Аутентификация с помощью OpenID Connect

OpenID Connect (кратко OIDC) — расширение OAuth, которое позволяет стандартным образом получать
информацию о пользователе в виде id token от сервера авторизации для аутентификации пользователей. Далее предстоит подключить
сервер авторизации Google по OpenID Connect, а также донастроить и подключить `IdentityServer`.


### 8.1. Шаг назад

В нескольких последующих заданиях нет необходимости в отдельном сервисе `PhotosService`.
Чтобы не приходилось его запускать, подключи `LocalPhotosRepository` вместо `RemotePhotosRepository` в `PhotosApp`:
```cs
services.AddScoped<IPhotosRepository, LocalPhotosRepository>();
//services.AddScoped<IPhotosRepository, RemotePhotosRepository>();
```
Нет смысла удалять строчку с `RemotePhotosRepository`, потому что далее она пригодится.


### 8.2. Аутентификация через Google по OpenID Connect

Google уже поддерживает протокол OpenID Connect, поэтому можно подключить Google по OIDC, а не по OAuth.

Для этого найди код подключения Google и замени его вот так:
```cs
//.AddGoogle("Google", options =>
//{
//    options.ClientId = context.Configuration["Authentication:Google:ClientId"];
//    options.ClientSecret = context.Configuration["Authentication:Google:ClientSecret"];
//})
.AddOpenIdConnect(
    authenticationScheme: "Google",
    displayName: "Google",
    options =>
    {
        options.Authority = "https://accounts.google.com/";
        options.ClientId = context.Configuration["Authentication:Google:ClientId"];
        options.ClientSecret = context.Configuration["Authentication:Google:ClientSecret"];

        options.CallbackPath = "/signin-google";
        options.SignedOutCallbackPath = "/signout-callback-google";
        options.RemoteSignOutPath = "/signout-google";

        options.Scope.Add("email");
    });
```

Настроек стало больше, они стали более явными:

- `Authority` — адрес сервера авторизации
- `CallbackPath` — адрес, на который будет возвращаться пользователь после успешного входа.
Адрес можно поменять в настройках клиента Google. Обработчик для запросов по этому пути будет добавлен
за счет `AddOpenIdConnect` и делать что-то дополнительно не нужно.
- `SignedOutCallbackPath` — адрес, на который будет возвращаться пользователь после успешного выхода
из аккаунта Google. Обработчик для запросов по этому пути будет добавлен за счет `AddOpenIdConenct`.
В любом случае с нашими настройками клиента таких запросов не будет.
- `RemoteSignOutPath` — адрес, на который происходил бы переход после `SignedOutCallbackPath`.
- `Scope.Add("email")` — дополнительно к скоупам oidc и profile запрашивается информация об email,
которая полезна при создании аккаунта в Identity.

Проверь, что аутентификация через Google по OpenID Connect работает. Как будто ничего и не поменялось.


### 8.3. Indentity.External

Пришло время лучше разобраться как работает аутентификация с помощью внешних провайдеров при использовании Identity.

Когда подключается Identity с помощью `AddDefaultIdentity` происходит регистрация нескольких схем аутентификации,
работающих по cookie. Основная из них уже знакомая `"Identity.Application"`. Но при первом входе пользователя
с помощью внешнего провайдера используется другая схема — `"Identity.External"`.


Разберем на конкретном примере Google и OIDC, хотя логика одинаковая для всех внешних провайдеров аутентификации.

Пусть пользователь решил войти через Google по OIDC. Он перенаправляется на сервер авторизации Google,
аутентифицируется там, а затем возвращается обратно в приложение по адресу `/signin-google`.
Этот запрос обрабатывается и вся ценная информация о пользователе сохраняется в некоторую «другую схему аутентификации».

Что же это за схема? Это схема, которая была указана `options.SignInScheme` при конфигурировании `AddOpenIdConnect`.
Но сейчас она не указана. Не проблема! Есть еще два кандидата, которые вот так регистрируются внутри `AddDefaultIdentity`:
```cs
services.AddAuthentication(o =>
    {
        o.DefaultScheme = IdentityConstants.ApplicationScheme;
        o.DefaultSignInScheme = IdentityConstants.ExternalScheme;
    })
```
`DefaultSignInScheme` — это более приоритетный кандидат в этом случае,
а `DefaultScheme` — кандидат для «любой непонятной ситуации» с аутентификацией.

Таким образом в нашем случае вся ценная информация о пользователе, которая была получена от Google будет сохранена
в схему `"Identity.External"` (это значение константы `IdentityConstants.ExternalScheme`),
т.е. в cookie, связанную с этой схемой.

После этого пользователю предлагается создать аккаунт в приложении по схеме `"Identity.Application"`
на основании данных из схемы `"Identity.External"`, возможно подтвердить его через почту и войти.
А cookie схемы `"Indentity.External"` по умолчанию существует совсем недолго и больше не используется.

При следующем входе через Google, например, после закрытия браузера, аккаунт в приложении уже существует
и можно сразу использовать схему `"Identity.Application"`, поэтому схема `"Identity.External"` не используется
и cookie для нее не создается.


Убедись, что все работает именно так, как описано.


Для начала — подготовка.

После вызова `AddDefaultIdentity` явно настрой cookie схемы `"Identity.External"`:
```cs
services.ConfigureExternalCookie(options =>
{
    options.Cookie.Name = "PhotosApp.Auth.External";
    options.Cookie.HttpOnly = true;
    options.ExpireTimeSpan = TimeSpan.FromMinutes(5);
    options.SlidingExpiration = true;
});
```
Здесь меняется имя куки, а остальные значения приведены для ознакомления и соответствуют значениям по-умолчанию.

Понизь требования для захода на страницу `Decode`:
```cs
options.AddPolicy(
    "Dev",
    policyBuilder =>
    {
        policyBuilder.RequireAuthenticatedUser();
        //policyBuilder.RequireRole("Dev");
        //policyBuilder.AddAuthenticationSchemes(
        //    JwtBearerDefaults.AuthenticationScheme,
        //    IdentityConstants.ApplicationScheme);
    });
```

Закомментируй подключение `SessionStore` при вызове метода `ConfigureApplicationCookie`:
```cs
//options.SessionStore = serviceProvider.GetRequiredService<EntityTicketStore>();
```
Это нужно, чтобы посмотреть значения из cookie, а не просто идентификатор сессии.


Теперь можно проверять:

1. Запусти приложение, открой его в браузере, зайди в него с помощью Google
и создай аккаунт в приложении.
2. Перейди на страницу «Decode» и убедись, что есть данные как из `PhotosApp.Auth` куки,
так и из `PhotosApp.Auth.External` куки. Причем в `PhotosApp.Auth.External` данных значительно больше.
3. Выйди из аккаунта с помощью кнопки «Logout», а затем снова войди с помощью Google.
4. Перейди на страницу «Decode» и убедись, что данных в `PhotosApp.Auth.External` нет, как и самой куки.


После входа пользователя Google передает данные в приложения в виде токенов, а уже затем информация из них
сохраняется в cookie. Но можно сделать так, чтобы сами токены сохранялись в cookie.

Добавь в вызов `AddOpenIdConnect` настройку:
```cs
options.SaveTokens = true;
```

Теперь зайди в приложение под аккаунтом Google и перейди на страницу «Decode».
Теперь в `PhotosApp.Auth.External` ты увидишь `id_token`.
Посмотри его содержимое с помощью `https://jwt.io`.

Теперь можешь закомментировать настройку `options.SaveTokens`: дальше не пригодится.


### 8.4. Генерация UI для IdentityServer

Если добавить к `IdentityServer` пользовательский интерфейс, то пользователи смогут регистрироваться в нем,
а затем использовать его для входа в сторонние приложения по OpenID Connect.


Чтобы не делать UI с нуля, можно использовать готовый шаблон.

Установи шаблоны `IdentityServer4` для dotnet CLI:
```
dotnet new -i IdentityServer4.Templates
```

Запусти генерацию UI в папку `IdentityServer`. Для этого из папки с solution выполни:
```
dotnet new is4ui -o IdentityServer
```
В результате в проекте `IdentityServer` должны появиться папки `Quickstart` и `Views`.

*Замечание. Похоже шаблон немного «битый». Поэтому попробуй сбилдить проект и добавь недостающие using-и.*

Чтобы добавленные представления и контроллеры в `IdentityServer` заработали, надо подключить MVC в `Startup.cs`.
Для этого просто раскомментируй код в `Startup.cs`.

Также надо подключить к `IdentityServer` тестовых пользователей. Для этого добавь вызов `AddTestUsers(TestUsers.Users)`
в цепочку вызовов после `AddIdentityServer` в `Startup.cs`:
```cs
var builder = services.AddIdentityServer()
    .AddInMemoryIdentityResources(Config.Ids)
    .AddInMemoryApiResources(Config.Apis)
    .AddInMemoryClients(Config.Clients);
    .AddTestUsers(TestUsers.Users); 
```


Запусти `IdentityServer` и убедись, что https://localhost:7001/ открывается без ошибок.
Затем перейди по ссылке в тексте «Click here to manage your stored grants», и в открывшейся форме зайди
под пользователем `alice`. Пароль от аккаунта можно посмотреть в файле `IdentityServer/Quckstart/TestUsers.cs`.
После успешного входа ты узнаешь, что у Alice нет «given access to any applications».


### 8.5. Passport

Пусть способ входа в `PhotosApp` через `IdentityServer` называется «Passport».
Теперь надо этот способ входа настроить.


В файле `Config.cs` найди статическое свойство `Clients` и добавь туда запись о новом клиенте:
```cs
new Client
    {
        ClientId = "Photos App by OIDC",
        ClientSecrets = { new Secret("secret".Sha256()) },

        AllowedGrantTypes = GrantTypes.Code,
        // NOTE: использовать ли Proof Key for Code Exchange
        // Это полезно для SPA и мобильных приложений, где client secret хранится у пользователя
        RequirePkce = true,
        // NOTE: показывать ли пользователю страницу consent со списком запрошенных разрешений
        RequireConsent = false,

        // NOTE: куда отправлять после логина
        RedirectUris = { "https://localhost:5001/signin-passport" },

        AllowedScopes = new List<string>
        {
            // NOTE: Позволяет запрашивать id token
            IdentityServerConstants.StandardScopes.OpenId,
            // NOTE: Позволяет запрашивать профиль пользователя через id token
            IdentityServerConstants.StandardScopes.Profile,
            // NOTE: Позволяет запрашивать email пользователя через id token
            IdentityServerConstants.StandardScopes.Email
        },

        // NOTE: Надо ли добавлять информацию о пользователе в id token при запросе одновременно
        // id token и access token, как это происходит в code flow.
        // Либо придется ее получать отдельно с user info endpoint.
        AlwaysIncludeUserClaimsInIdToken = true,
    }
```
Этой записью добавляется клиент по Code Flow, т.е. так же, как был добавлен Google.
Все остальное должно быть понятно из комментариев.

Так как предлагается давать доступ к скоупам profile и email, то надо определить, что это такое.
Для этого файле `Config.cs` найди статическое свойство `Ids` и добавь туда новые наборы ресурсов:
```cs
new IdentityResources.Profile(),
new IdentityResources.Email()
```

Под каждым `IdentityResource` подразумевается некоторый скоуп, набор claims о пользователе, который клиент
сможет получить через id token. Например, скоуп `"email"` включает в себя такие claims: `"email"`, `"email_verified"`.


Теперь `IdentityServer` настроен, осталось настроить приложение. Используй этот шаблон и настройки клиента,
чтобы добавить новый способ аутентификации в `IdentityHostingStartup.cs`:
```cs
services.AddAuthentication()
    .AddOpenIdConnect("Passport", "Паспорт", options =>
    {
        options.Authority = "TODO: адрес сервера авторизации";

        options.ClientId = "TODO";
        options.ClientSecret = "TODO";
        options.ResponseType = "code";

        // NOTE: oidc и profile уже добавлены по-умолчанию
        options.Scope.Add("TODO: запросить все доступные скоупы");

        options.CallbackPath = "TODO: куда отправлять после логина";

        // NOTE: все эти проверки токена выполняются по умолчанию, указаны для ознакомления
        options.TokenValidationParameters.ValidateIssuer = true; // проверка издателя
        options.TokenValidationParameters.ValidateAudience = true; // проверка получателя
        options.TokenValidationParameters.ValidateLifetime = true; // проверка не протух ли
        options.TokenValidationParameters.RequireSignedTokens = true; // есть ли валидная подпись издателя
    });
```


Запусти IdentityServer и PhotosApp, а затем войди через «Паспорт» аналогично тому, как раньше входил через Google.
Вход должен работать, email при создании аккаунта подставляться из `IdentityServer`, а информация о профиле
пользователя видна на странице «Decode» в `PhotosApp.Auth.External` куке.


### 8.6. Claims из внешнего провайдера

Пользователи из `IdentityServer` могут входить в `PhotosApp`, но функционал приложения для них ограничен,
потому что у них нет ни доступа к бета-версиям, ни платной подписке. Надо добавить пользователям `IdentityServer`
права и сделать так, чтобы информация об этом попадала в `PhotosApp`.


В начале добавь новые claims для пользователей из `IdentityServer`. Найди файл `IdentityServer/Quckstart/TestUsers.cs`
и добавь пользователю `alice` такие claims:
```cs
new Claim("subscription", "paid"),
new Claim("testing", "beta"),
new Claim("role", "Dev")
```

Чтобы эти claims можно было запросить нужно создать новый scope для id token.
Для этого в файле `Config.cs` добавь новый `IdentityResource` с названием `photos_app`, включающий добавленные claims:
```cs
new IdentityResource("photos_app", new []
{
    "role", "subscription", "testing"
})
```

Дай клиенту `"Photos App by OIDC"` доступ к новому scope `photos_app`, прописав его в `AllowedScopes`.

Теперь в `PhotosApp` сделай так, чтобы scope `photos_app` при аутентификации через Passport.
Это можно сделать аналогично scope `email`.


Самый ответственный шаг: полученные данные от сервера авторизации данные нужно сохранить.
Пусть это происходит при создании аккаунта в приложении.

Для этого в `Areas/Identity/Pages/AccountExternalLogin.cshtml.cs` найди метод `OnPostConfirmationAsync`.
Именно этот метод вызывается после входа через внешний провайдер, если в приложении еще нет аккаунта.

В начале метода получаются данные из внешней схемы:
```cs
var info = await _signInManager.GetExternalLoginInfoAsync();
```

Если все хорошо, то создается пользователь и к нему привязывается способ входа через внешний провайдер:
```cs
var user = new PhotosAppUser { UserName = Input.Email, Email = Input.Email };
var result = await _userManager.CreateAsync(user);
...
result = await _userManager.AddLoginAsync(user, info);
```

И, наконец, когда все это успешно выполнено можно сохранить дополнительные claims из внешнего провайдера
в новый аккаунт в приложении.
Для этого после строчки `_logger.LogInformation("User created an account using {Name} provider.", info.LoginProvider);`
добавь такой код:
```cs
// NOTE: сохранение полученные от провайдера claims
if (info.Principal.HasClaim(c => c.Type == ClaimTypes.Role))
    await _userManager.AddClaimAsync(user, info.Principal.FindFirst(ClaimTypes.Role));
if (info.Principal.HasClaim(c => c.Type == "subscription"))
    await _userManager.AddClaimAsync(user, info.Principal.FindFirst("subscription"));
if (info.Principal.HasClaim(c => c.Type == "testing"))
    await _userManager.AddClaimAsync(user, info.Principal.FindFirst("testing"));
```


Теперь проверка. Зайди в приложение под пользователем `alice` через Passport.
Убедись, что ей доступно добавление фотографий и оно работает.
Перейди на страницу «Decode» и убедись, что `subscription`, `testing` и `role` прописаны в `User`.
Полное имя claim `role` — `http://schemas.microsoft.com/ws/2008/06/identity/claims/role`.
Данные о User — в самом низу страницы.
 

### 8.7. Logout из внешнего провайдера

Что должно происходить, когда пользователь, вошедший через внешнего провайдера хочет выйти?
Надо просто выйти из приложения или еще выйти во внешнем провайдере?
Если пользователь зашел с помощью Google и хочет выйти из приложения `PhotosApp`,
то скорее всего надо просто выйти из приложения. Но если он нажал выход в приложении `Google Photos`,
то пожалуй он хочет выйти из своего Google-аккаунта.

Реализуй для Passport подобное поведение: пусть пользователь, вошедший через Passport,
при выходе из `PhotosApp` также выходит из Passport.


Для этого найди `PhotosApp\Areas\Identity\Pages\Account\Logout.cshtml.cs`
и поменяй содержимое метода `OnPost` на такое:
```cs
public async Task<IActionResult> OnPost(string returnUrl = null)
{
    await _signInManager.SignOutAsync();
    _logger.LogInformation("User logged out.");
    if (User?.FindFirst(ClaimTypes.AuthenticationMethod)?.Value == "Passport")
    {
        return SignOut("Passport");
        // NOTE: это более явный вариант предыдущей строчки
        //await HttpContext.SignOutAsync("Passport");
        //return new EmptyResult();
    }
    if (returnUrl != null)
    {
        return LocalRedirect(returnUrl);
    }
    else
    {
        return RedirectToPage();
    }
}
```

Теперь можешь убедиться, что при нажатии на кнопку «Logout» происходит выход из приложения,
а затем выход в `IdentityServer`. При этом пользователь остается на странице `IdentityServer`.

Это как-то неудобно. Правильнее было бы вернуть пользователя на главную страницу `PhotosApp`.
Так можно сделать, но есть «подводные камни».

Во-первых, в настройках в вызове `AddOpenIdConnect` для Passport надо задать адрес, на который
надо возвращать пользователя после выхода.
```cs
options.SignedOutCallbackPath = "/signout-callback-passport";
```
Строго говоря, у `SignedOutCallbackPath` уже было задано значение `/signout-callback-oidc` по-умолчанию.
Но лучше значением по-умолчанию не пользоваться: если в приложение добавить несколько OIDC,
то при настройках по-умолчанию непонятно кто будет обрабатывать запрос на выход.

Явного задания `SignedOutCallbackPath` недостаточно. Да, приложение предложит `IdentityServer` сделать редирект
по этому адресу. Но `IdentityServer` не будет делать редирект непонятно куда.

Поэтому, во-вторых, надо зарегистрировать этот адрес в клиенте `"Photos App by OIDC"` в `Config.cs` в `IdentityServer`:
```cs
// NOTE: куда предлагать перейти после логаута
PostLogoutRedirectUris = { "https://localhost:5001/signout-callback-passport" },
```

Можешь убедиться, что так тоже работать не будет. Все дело в том, что `IdentityServer` требует предъявить при выходе
некоторый id token пользователя в качестве «подсказки», т.е. передать в запросе `id_token_hint`.

Обработчик OpenID Connect умеет отправлять `id_token_hint`, если id token доступен в сессии, т.е. в нашем случае лежит
в куки схемы `Identity.Application`. Проблема в том, что его там пока нет.

Поэтому, в-третьих, надо добавить сохранение токенов в вызов `AddOpenIdConnect` для Passport:
```cs
options.SaveTokens = true;
```

А в-четвертых, надо переносить эти токены из схемы `"Identity.External"` в схему `"Identity.Application"`.
И это надо делать в двух случаях: и после регистрации нового аккаунта в приложении и в случае входа в существующий аккаунт.

Для случая регистрации в методе `OnPostConfirmationAsync` в `ExternalLogin.cshtml.cs` найди вызов `_signInManager.SignInAsync`
и замени его на такой код:
```cs
// NOTE: сохранение полученных от провайдера токенов
var props = new AuthenticationProperties();
props.StoreTokens(info.AuthenticationTokens);
props.IsPersistent = false;
await _signInManager.SignInAsync(user, props, info.LoginProvider);
```

Для случая входа в существующий аккаунт в методе `OnGetCallbackAsync` в `ExternalLogin.cshtml.cs` найди код:
```cs
var result = await _signInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, isPersistent: false, bypassTwoFactor : true);
if (result.Succeeded)
{
    ...
}
```
и внутри этого `if` добавь код:
```cs
// NOTE: перелогин с сохранением полученных от провайдера токенов
var user = await _userManager.FindByLoginAsync(info.LoginProvider, info.ProviderKey);
var props = new AuthenticationProperties();
props.StoreTokens(info.AuthenticationTokens);
props.IsPersistent = false;
await _signInManager.SignInAsync(user, props, info.LoginProvider);
```

*Замечание. В методе `OnGetCallbackAsync` при вызове `_signInManager.ExternalLoginSignInAsync` происходит попытка входа*
*в аккаунт приложения, соответствующий аккаунту из внешнего провайдера. Если аккаунт не найден, то происходит переход*
*к регистрации нового аккаунта. А вот если найден, то надо сохранить полученные от внешнего провайдера токены.*
*Так как у метода `ExternalLoginSignInAsync` нет перегрузки, которая позволяет задать `AuthenticationProperties`,*
*приходится делать «повторный вход». Для пользователя это незаметно.*
*Более элегантное, но трудоемкое решение — создать наследника `SignInManager`,*
*у которого будет нужная перегрузка `ExternalLoginSignInAsync`.*


Вот теперь можно убедиться, что выход из приложения работает правильно: происходит редирект
на страницу выхода в `IdentityServer`, на которой есть ссылка для возврата в приложение `PhotosApp`.


Еще один штрих. Вход для внешних провайдеров настроен так, что после закрытия браузера сессия завершается.
А значит при следующем входе снова придется входить. Может быть это удобно входа через Google.
Но для Passport это немного странно, ведь интеграция с ним более тесная: теперь даже выход происходит одновременно.

Поэтому найди строчки `props.IsPersistent = false;`, которые ты добавил в методы `OnGetCallbackAsync`
и `OnPostConfirmationAsync`, и замни их на `props.IsPersistent = info.LoginProvider == "Passport";`

Можешь убедиться, что теперь после закрытия браузера сессия не теряется и заново входить не приходится.

*Замечание. Это в разработке приводит к некоторому эффекту, похожему на баг.*
*При перезапуске приложения пользователи пересоздаются, а сессия для удаленного пользователя остается в браузере.*
*В результате при переходе в профиль и других действиях можно увидеть ошибки.*
*При нормальной работе приложения такого эффекта не будет,*
*поэтому его можно игнорировать и просто выходить из старой сессии.*


### 8.8. Шаг вперед

Работа по подключению OpenID Connect закончена и далее вновь потребуется `PhotosService`.
Снова подключи `RemotePhotosRepository`:
```cs
//services.AddScoped<IPhotosRepository, LocalPhotosRepository>();
services.AddScoped<IPhotosRepository, RemotePhotosRepository>();
```


Сейчас аутентификацию и авторизацию в приложении `PhotosApp` можно считать законченной:
- можно войти по логину и паролю, а также с помощью Google и Passport
- есть хакерский доступ через JwtToken, хотя его уже можно разобрать
- взаимодействие с `PhotosService` защищено с помощью Client Credentials Flow

На этом можно остановиться.
Но аутентификацию в приложении можно построить иначе, полностью делегировав ее `IdentityServer`
и отказавшись от собственной `Identity`. Следующие задания будут посвящены переходу от `Identity` к `IdentityServer`.


## 9. Авторизация в другом сервисе с помощью Authorization Code Flow

Client Credentials Flow позволяет защищать сервисы от запросов неизвестных приложений.
Но если приложение имеет доступ к сервису, то оно получает доступ к данным всех пользователей в этом сервисе.
Более правильный подход — выдавать access token для конкретного пользователя, чтобы приложение могло
совершать в сервисе действия только с данными этого конкретного пользователя.

Code Flow и Implicit Flow в OAuth и соответствующие Flow в OpenID Connect позволяют получать такие access token.

Далее надо научиться получать в `PhotosApp` access token для пользователя от `IdentityServer`,
чтобы затем авторизоваться с этими токенами в `PhotosService`.


### 9.1. Авторизация по access token пользователя

Ресурс `photos_service` уже существует в `IdentityServer` и access tokens, выпущенные с таким скоупом будут приниматься
в `PhotosService`. Это упрощает задачу.

Чтобы `IdentityServer` присылал правильный access token вместе с id token:

1. В `PhotosApp` в конфигурации Passport добавь `"photos_service"` в `options.Scope`
2. В `IdentityServer` добавь `"photos_service"` в `AllowedScopes` клиента `"Photos App by OIDC"`

Хорошо бы явно спросить хочет ли пользователь давать `PhotosApp` разрешение на доступ к `PhotosService`.
Поэтому в настройках клиента `"Photos App by OIDC"` замени значение настройки `RequireConsent` на `true`.
После этого `IdentityServer` начнет показывать страницу со списком запрашиваемых приложением разрешений.

В одном из предыдущих заданий уже было реализовано сохранение токенов, пришедших от внешних провайдеров
в схему `"Identity.Application"`, поэтому access token также будет сохраняться.

А это значит, что осталось только в `RemotePhotosRepository` передавать access token пользователя вместо access token,
запрашиваемого по Client Credentials Flow.

Для этого поправь метод `SendAsync` в `RemotePhotosRepository` вот так:
```cs
private async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request)
{
    var httpContext = httpContextAccessor.HttpContext;
    
    // NOTE: По умолчанию используется DefaultAuthenticateScheme, либо DefaultScheme.
    var accessToken = await httpContext.GetTokenAsync(
        IdentityConstants.ApplicationScheme,
        OpenIdConnectParameterNames.AccessToken);
    if (accessToken == null)
        return new HttpResponseMessage(HttpStatusCode.Unauthorized);

    var httpClient = new HttpClient();
    httpClient.SetBearerToken(accessToken);
    var response = await httpClient.SendAsync(request);
    return response;
}
```
Чтобы этот метод работал надо с помощью Dependency Injection через конструктор получить `IHttpContextAccessor`
и сохранить ее в поле httpContextAccessor.


После выполнения этих действий убедись, что пользователь `alice` при входе через Passport видит
страницу со списком разрешений, а после входа может добавлять фотографии.
А вот фотографии пользователей приложения, например, `vicky@gmail.com`, больше не показываются.


### 9.2. Контроль доступа с помощью access token

Сейчас каждый access token, приходящий в `PhotosService` создержит информацию о пользователе,
в частности, его идентификатор. Этого достаточно, чтобы `PhotosService` мог предоставить пользователю
доступ к его фотографиям и запретить к ним доступ для всех других пользователей.
Следовательно, можно отказаться от политики `MustOwnPhoto` в пользу access token.


Закомментируй атрибут `[Authorize(Policy = "MustOwnPhoto")]` в `PhotoController`.

А теперь поставь эксперимент:

1. Зайди под `alice` через Passport и загрузи фотографию.
2. Перейди на страницу с одной фотографией и сохрани URL страницы
3. Выполни logout и зайди под пользователем `bob`
4. Используй сохраненный URL, чтобы открыть фотографию. Она снова будет доступна.

А теперь надо настроить использование access token, чтобы вновь фотографии пользователя
были доступны только самому пользователю.


Все, что надо сделать — это получить access token в методах `PhotosApiController` и добавить проверку владельца.
Например, в методе `GetPhotoContent` проверка могла бы выглядеть примерно так, если предположить,
что в `accessToken.Subject` находится идентификатор пользователя:
```cs
var photoEntity = await photosRepository.GetPhotoMetaAsync(id);
if (photoEntity == null)
    return NotFound();
if (accessToken.Subject != photoEntity.OwnerId)
    return Forbid();
```


Но как получить токен?
Есть способ, который уже использовался:
```cs
var accessToken = await HttpContext.GetTokenAsync("access_token");
```
Рабочий способ. Недостаток только в том, что вернется строка, которую еще надо будет десериализовать.
Конечно, для десериализации можно будет использовать что-то готовое, ведь раз ASP.NET Core
как-то достает информацию из токенов, значит есть способ.

Другая идея — `ModelBinder`. Специальный код, который из запроса достанет нужную информацию и положит
в качестве параметра в метод контроллера. Чтобы получилось как-то так:
```cs
GetPhotoContent(Guid id, JwtSecurityToken accessToken)
```

Причем вообще-то ASP.NET Core действительно десериализовывает access token, чтобы его проверить.
И после проверки сообщает об этом с помощью события. Как следствие в опциях `AddJwtBearer`
можно написать код перехвата токена после проверки:
```cs
options.Events = new JwtBearerEvents
{
    OnTokenValidated = context =>
    {
        // NOTE: с полученным токеном можно что-то сделать
        var accessToken = context.SecurityToken;
        // NOTE: например, сохранить куда-нибудь в HttpContext, чтобы потом достать в контроллере
        var httpContext = context.HttpContext;
        return Task.CompletedTask;
    }
};
```


Воспользуйся вторым способом с перехватом и ModelBinder. Для этого:

1. В `Startup.cs` в `PhotosServices` добавь в `AddJwtBearer` такой код:
```cs
options.Events = new JwtBearerEvents
{
    OnTokenValidated = context =>
    {
        JwtSecurityTokenModelBinder.SaveToken(context.HttpContext, context.SecurityToken);
        return Task.CompletedTask;
    }
};
```

2. Там же, но в методе `ConfigureServices` дополни опции вызова `AddControllers`:
```cs
services.AddControllers(options =>
{
    options.ReturnHttpNotAcceptable = true;
    // NOTE: Существенно, что новый провайдер добавляется в начало списка перед провайдером по-умолчанию
    options.ModelBinderProviders.Insert(0, new JwtSecurityTokenModelBinderProvider());
})
```

3. Найди `JwtSecurityTokenModelBinderProvider` и `JwtSecurityTokenModelBinder` и посмотри как они работают.

4. Теперь вот этот код для `GetPhotoContent` действительно будет работать:
```cs
[HttpGet("{id}/content")]
public async Task<IActionResult> GetPhotoContent(Guid id, JwtSecurityToken accessToken)
{
    var photoEntity = await photosRepository.GetPhotoMetaAsync(id);
    if (photoEntity == null)
        return NotFound();
    if (accessToken.Subject != photoEntity.OwnerId)
        return Forbid();

    ...
}
```
Используй его, чтобы защитить `GetPhotoContent`.


Теперь защити все оставшиеся методы `PhotosApiController`. Идея простая: если `ownerId` не совпадает
с `accessToken.Subject`, то надо вернуть `Forbid()`.

*Замечание. `JwtSecurityToken` — это сложный тип, поэтому по-умолчанию ASP.NET Core пытается значение этого типа*
*получить из body запроса. `JwtSecurityTokenModelBinder` это не проблема, пока не появится другой параметр*
*со сложным типом, значение которого надо получать из body. Как, например, в методах `AddPhoto` и `UpdatePhoto`.*
*Поэтому в этих методах придется `accessToken` помечать атрибутом `[FromHeader]`:*
```cs
public async Task<IActionResult> AddPhoto(PhotoToAddDto photo, [FromHeader] JwtSecurityToken accessToken)
```


Повтори эксперимент с `alice` и `bob`. Теперь у `bob` не должна открываться фотография `alice`.


### 9.3. Перенос пользователей в IdentityServer

После недавних изменений все пользователи `PhotosApp`, не привязанные к `IdentityServer`
потеряли доступ к своим фотографиям. Это можно было избежать, продолжая использовать для них access token,
полученный через Client Credentials Flow.

Но по плану в конце концов все пользователи должны оказаться в `IdentityServer`,
поэтому просто перенеси всех пользователей `PhotosApp` в `IdentityServer`.


В файле `IdentityServer/Quckstart/TestUsers.cs` добавь записи о пользователях из `PhotosApp`:
```cs
new TestUser{SubjectId = "a83b72ed-3f99-44b5-aa32-f9d03e7eb1fd", Username = "vicky@gmail.com", Password = "Pass!2",
    Claims =
    {
        new Claim(JwtClaimTypes.Email, "vicky@gmail.com"),
        new Claim("testing", "beta"),
    }
},
new TestUser{SubjectId = "dcaec9ce-91c9-4105-8d4d-eee3365acd82", Username = "cristina@gmail.com", Password = "Pass!2",
    Claims =
    {
        new Claim(JwtClaimTypes.Email, "cristina@gmail.com"),
        new Claim("subscription", "paid"),
    }
},
new TestUser{SubjectId = "b9991f69-b4c1-477d-9432-2f7cf6099e02", Username = "dev@gmail.com", Password = "Pass!2",
    Claims =
    {
        new Claim(JwtClaimTypes.Email, "dev@gmail.com"),
        new Claim("subscription", "paid"),
        new Claim("role", "Dev")
    }
}
```

А вот в файле `PhotosApp/Data/DataExtensions.cs` в методе `SeedWithSampleUsersAsync` закомментируй добавление
всех пользователей, чтобы пользователи в `PhotosApp` больше не создавались. Удаление существующих пользователей оставь.


Теперь можно зайти под `vicky@gmail.com` через Passport, но ее фотографии все равно не будут доступны. Убедись в этом.

Так происходит потому, что ее фотографии хранятся под идентификатором `"a83b72ed-3f99-44b5-aa32-f9d03e7eb1fd"`,
а `PhotoController` использует идентификатор пользователя `Identity`, который создается при входе через Passport.

Поэтому надо сделать две вещи:

1. Сохранять идентификатор пользователя из Passport при создании пользователя Identity.
Для этого в `Areas/Identity/Pages/AccountExternalLogin.cshtml.cs` в методе `OnPostConfirmationAsync`
добавь добавление еще одного claim:
```cs
if (info.Principal.HasClaim(c => c.Type == ClaimTypes.NameIdentifier))
    await _userManager.AddClaimAsync(user, new Claim("passport_id",
        info.Principal.FindFirstValue(ClaimTypes.NameIdentifier)));
```

2. Используй идентификатор пользователя из Passport в `PhotoController` и для этого поменяй метод `GetOwnerId`:
```cs
private string GetOwnerId()
{
    //return User.FindFirstValue(ClaimTypes.NameIdentifier);
    return User.FindFirstValue("passport_id");
}
```


Теперь зайди под `vicky@gmail.com` через Passport и убедись, что ее фотографии показываются.


### 9.4. Refresh token

Текущая схема с access-токенами не учитывает одного важного нюанса — обычно access-токен имеет небольшое время жизни.
А все потому, что access-токены обычно нельзя отозвать: если сервису предъявили подписанный действующий access-токен,
то у сервиса нет причин отказать в доступе. Даже если пользователь через сервер авторизации уже запретил доступ для
приложения, которое успело получить access-токен. Раз нельзя отозвать, то пусть хоть действует недолго.

Но из этого следует, что нужно каким-то образом уметь получать новый access-токен, когда старый перестанет действовать.
И не отвлекать на это каждые 5 минут пользователя, который увлеченно пользует приложением, которому предоставил доступ.

Для получения новых access-токенов есть специальный refresh-токен. Приложение может запросить refresh-токен вместе
с access-токеном и, если пользователь даст разрешение, то приложение его получит. Используя refresh-токен приложение
может получить access-токен, когда старый перестанет действовать или даже раньше. Сам же refresh-токен имеет
продолжительный срок жизни, это могут быть месяцы. Более того, вместе с новым access-токеном обычно приходит
новый refresh-токен, поэтому refresh-токен в приложении можно постоянно обновлять,
а значит он будет всегда действителен. Но зато refresh-токен можно отозвать: если пользователь сообщит
серверу авторизации, что больше не хочет предоставлять доступ приложению, то сервер авторизации больше не будет
выдавать по refresh-токенам приложения новые access-токены.


Для начала усугуби проблему. Сделай так, что access-токены от `IdentityServer` были действительны только полминуты.
Для этого в `Config.cs` в настройках клиента `"Photos App by OIDC"` добавь такую опцию:
```cs
AccessTokenLifetime = 30
```

При проверки времени действия токена есть допустимая погрешность. Она теперь будет мешать, поэтому выстави ее в 0.
Для этого в `PhotosService` в `Startup.cs` в опциях `AddJwtBearer` пропиши:
```cs
options.TokenValidationParameters.ClockSkew = TimeSpan.Zero;
```


Теперь войди под пользователем `vicky@gmail.com` через Passport. На главной странице должны подгрузиться фотографии.
Подожди полминуты и обнови главную страницу. Фотографии должны пропасть, т.к. access token перестал действовать.


Проблема очевидна. И пришло время ее решить.

Для этого надо, чтобы приложение запрашивало refresh-токен, а сервер авторизации его предоставлял.

1. Добавь в настройках Passport в `PhotosApp` такую опцию:
```cs
options.Scope.Add("offline_access");
```

2. Добавь в настройках клиента `"Photos App by OIDC"` в `IdentityServer` такую опцию:
```cs
AllowOfflineAccess = true
```

После этих действий refresh-токен будет получаться вместе с access-токеном, а в нашем случае благодаря правкам
в `ExternalLogin.cshtml.cs` и сохраняться в куки схемы `"Identity.Application"`.


Осталось научиться получать access-токены с помощью refresh-токенов. Пусть стратегия будет «наивной»:
если на запрос из `RemotePhotosRepository` приходит ответ `401 Unauthorized`, то наверное access token
больше не действует и надо запросить новый, а затем повторить запрос. Если повторный запрос провалился,
то снова делать ничего не надо.

В соответствие с этой логикой метод `SendAsync` в `RemotePhotosRepository` может быть таким:
```cs
private async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request)
{
    var httpContext = httpContextAccessor.HttpContext;
    
    // NOTE: По умолчанию используется DefaultAuthenticateScheme, либо DefaultScheme.
    var accessToken = await httpContext.GetTokenAsync(
        IdentityConstants.ApplicationScheme,
        OpenIdConnectParameterNames.AccessToken);
    if (accessToken == null)
        return new HttpResponseMessage(HttpStatusCode.Unauthorized);

    var httpClient = new HttpClient();
    httpClient.SetBearerToken(accessToken);
    var response = await httpClient.SendAsync(request);
    if (response.StatusCode != HttpStatusCode.Unauthorized)
        return response;

    var refreshToken = await httpContext.GetTokenAsync(
        IdentityConstants.ApplicationScheme,
        OpenIdConnectParameterNames.RefreshToken);
    if (refreshToken == null)
        return new HttpResponseMessage(HttpStatusCode.Unauthorized);

    // NOTE: запрос нового access token
    var newAccessToken = await RefreshAccessTokenAsync(refreshToken);
    if (newAccessToken != null)
    {
        // NOTE: повторный запрос
        var newHttpClient = new HttpClient();
        newHttpClient.SetBearerToken(newAccessToken);
        // NOTE: HttpRequestMessage нельзя использовать два раза, поэтому он копируется
        var secondRequest = await request.CopyAsync();
        var secondResponse = await newHttpClient.SendAsync(secondRequest);
        return secondResponse;
    }

    return new HttpResponseMessage(HttpStatusCode.Unauthorized);
}

private async Task<string> RefreshAccessTokenAsync(string refreshToken)
{
    throw new NotImplementedException();
}
```

Но как реализовать `RefreshAccessTokenAsync`?
Для получения access token нужно сделать запрос к token endpoint `IdentityServer`.
Это означает, что надо получить информацию о `IdentityServer`. Ту самую, которую ты раньше уже получал
вручную по адресу https://localhost:7001/.well-known/openid-configuration.

Для этого можно NuGet-пакет `IdentityModel`: там есть специальный класс `DiscoveryCache`,
который умеет не только получать настройки, но и кэшировать их, чтобы не запрашивать их при каждом запросе.

Но есть еще один вариант: получать конфигурацию также, как это происходит при подключении аутентификации
через `AddOpenIdConnect`. Понятно же, что раз приложение уже получает какие-то токены от `IdentityServer`,
то оно умеет и его конфигурацию получать. Отвечает за получение и кэширование конфигурации
тип `IConfigurationManager<OpenIdConnectConfiguration>`.

Его экземпляр создается глубоко внутри `AddOpenIdConnect`, но можно создать свой экземпляр
и передать внутрь `AddOpenIdConnect` — тогда внутри `IConfigurationManager` создаваться не будет.
А значит кэш с настройками будет существовать в единственном экземпляре.

Создай и зарегистрируй в `services` свой `configurationManager` в файле `IdentityHostingStartup.cs` вот так:
```cs
const string oidcAuthority = "https://localhost:7001";
var oidcConfigurationManager = new ConfigurationManager<OpenIdConnectConfiguration>(
    $"{oidcAuthority}/.well-known/openid-configuration",
    new OpenIdConnectConfigurationRetriever(),
    new HttpDocumentRetriever());

services.AddSingleton<IConfigurationManager<OpenIdConnectConfiguration>>(oidcConfigurationManager);
```

А в вызов `AddOpenIdConnect` добавь в опции:
```cs
options.ConfigurationManager = oidcConfigurationManager;
```

Теперь можно получить `IConfigurationManager<OpenIdConnectConfiguration> oidcConfigurationManager`
через конструктор `RemotePhotosRepository` и сохранить в поле для использования в методах.

Наконец, можно написать реализацию `RefreshAccessTokenAsync`, которая будет использовать
`IConfigurationManager` для получения настроек и NuGet-пакет `IdentityModel`,
чтобы сформировать верный запрос к token endpoint.
```cs
private async Task<string> RefreshAccessTokenAsync(string refreshToken)
{
    var httpContext = httpContextAccessor.HttpContext;

    // NOTE: получение конфигурации сервера авторизации
    // NOTE: если исходный запрос будет отменен, то использование RequestAborted отменит запрос конфигурации
    var oidcConfiguration = await oidcConfigurationManager.GetConfigurationAsync(httpContext.RequestAborted);

    // NOTE: запрос токенов с помощью IdentityModel
    var tokenResponse = await new HttpClient().RequestRefreshTokenAsync(new RefreshTokenRequest
    {
        Address = oidcConfiguration.TokenEndpoint,
        ClientId = "Photos App by OIDC",
        ClientSecret = "secret",
        RefreshToken = refreshToken,
    });

    // NOTE: обновление access token и refresh token в аутентификационной cookie
    var authResult = await httpContext.AuthenticateAsync(IdentityConstants.ApplicationScheme);
    if (tokenResponse.RefreshToken != null)
        authResult.Properties.UpdateTokenValue(OpenIdConnectParameterNames.RefreshToken, tokenResponse.RefreshToken);
    if (tokenResponse.AccessToken != null)
        authResult.Properties.UpdateTokenValue(OpenIdConnectParameterNames.AccessToken, tokenResponse.AccessToken);
    await httpContext.SignInAsync(IdentityConstants.ApplicationScheme, authResult.Principal, authResult.Properties);

    return tokenResponse.AccessToken;
}
```


Теперь можно повторить эксперимент. Войди под пользователем `vicky@gmail.com` через Passport.
На главной странице должны подгрузиться фотографии. Подожди полминуты и обнови главную страницу.
Фотографии должны остаться.


### 9.5. Валидация токенов

Вообще-то можно не отправлять заведомо старые access-токены в `PhotosService`.
Можно проверять access-токен перед запросом и, если он старый, то сразу запрашивать новый.


Свою реализацию проверки токена писать, конечно, не нужно, ведь в .NET уже есть готовая.

Добавь в `RemotePhotosRepository` такой метод проверки:
```cs
private async Task<TokenValidationResult> ValidateTokenAsync(string accessToken)
{
    var validationParameters = new TokenValidationParameters
    {
        ValidateIssuer = false,
        ValidateAudience = false,
        ValidateLifetime = true,
        ClockSkew = TimeSpan.Zero,
        // NOTE: Небольшая хитрость, чтобы подпись не проверялась,
        // ведь ее не получится проверить без закрытого ключа
        SignatureValidator = (token, validationParameters) => new JsonWebToken(token)
    };

    var tokenHandler = new JsonWebTokenHandler();
    var validationResult = tokenHandler.ValidateToken(accessToken, validationParameters);
    return validationResult;
}
```
В нем `TokenValidationParameters` настраиваются таким образом, чтобы проверялось только время жизни токена.

Теперь перепиши `SendAsync` так, чтобы перед первым запросом к `PhotosService` проверялся токен и сам запрос
происходил только в том случае, когда `validationResult.IsValid`. А иначе сразу доставался refresh token,
запрашивался новый access token и запрос к `PhotosService` происходил уже с новым access token.


Раз уж возник вопрос валидации токенов, то исключительно ради эксперимента, добавь проверку
подписи токена в `ValidateTokenAsync`. Это на самом деле не требуется, т.к. подпись id token проверяется
при аутентификации, а подпись access token будет в любом случае проверяться `PhotosService`.
Но уметь проверять в коде токен полезно. Тем более, что уже вручную проверять умеешь.

Итак, для начала придется получить конфигурацию сервера авторизации и JWK из нее:
```cs
var httpContext = httpContextAccessor.HttpContext;
var oidcConfiguration = await oidcConfigurationManager.GetConfigurationAsync(httpContext.RequestAborted);
var issuerSigningKeys = oidcConfiguration.SigningKeys;
```

А затем подправить `TokenValidationParameters` перед проверкой вот так:
```cs
// NOTE: если все же хочется проверить подпись, то хитрость не нужна
validationParameters.SignatureValidator = null;
validationParameters.IssuerSigningKeys = issuerSigningKeys;
// NOTE: токены совсем без подписи вообще-то надо всегда отбрасывать — они ничтожны
validationParameters.RequireSignedTokens = true;
```


### 9.6. Сохранение токенов

Сейчас все токены, полученные приложением хранятся в http-only cookie.
Это достаточно безопасно: современные браузеры гарантируют, что скрипты, в том числе скрипты злоумышленников,
не смогут получить доступ к таким cookie, а https может гарантировать, что cookie не будут перехвачены при передаче.

Но можно токены вообще не передавать в браузер. Например, за счет использования `TicketStore` и сессий.
А еще их можно сохранить в базу данных для пользователя и доставать, когда потребуется.

Сохранять токены в базу данных может потребоваться не только из соображений безопасности,
но и для того, чтобы выполнять некоторые действия от имени пользователя, когда тот находится «offline»:
достаточно просто достать refresh token из БД, получить access token — и можно делать все, что разрешил пользователь.


Короче, полезное это дело уметь сохранять токены в базу данных. И это несложно сделать.
Просто добавь в вызов вызова `AddOpenIdConnect` в опции обработку события получения токенов:
```cs
options.Events = new OpenIdConnectEvents()
{
    OnTokenResponseReceived = context =>
    {
        var tokenResponse = context.TokenEndpointResponse;

        var tokenHandler = new JwtSecurityTokenHandler();
        if (tokenResponse.AccessToken != null)
        {
            var accessToken = tokenHandler.ReadToken(tokenResponse.AccessToken);
        }
        if (tokenResponse.IdToken != null)
        {
            var idToken = tokenHandler.ReadToken(tokenResponse.IdToken);
        }
        if (tokenResponse.RefreshToken != null)
        {
            // NOTE: Это не JWT-токен
            var refreshToken = tokenResponse.RefreshToken;
        }

        return Task.CompletedTask;
    }
};
```
Добавь и с помощью отладки проверь, что токены действительно приходят.


## 10. Аутентификация только через IdentityServer

Пришло время окончательно отказаться от `Identity` в `PhotosApp` в пользу `IndetityServer`.
Заодно и от других способов аутентификации. Пусть все сложности аутентификации будут собраны в одном месте!
`IdentityServer` — это прекрасное решение для компаний, у которых много веб-приложений, потому что не нужно
в каждом реализовывать логику аутентификации и управления пользователями! Да и пользователи в одном месте!


Прежде всего придется закомментировать много кода!


В `IdentityHostingStartup.cs` закомментируй почти все. Проще перечислить то, что должно остаться:

- Создание `oidcConfigurationManager`

- Подключение Passport:
```cs
services.AddAuthentication()
    .AddOpenIdConnect("Passport", "Паспорт", options =>
    {
        ...
    }
```

- Политики авторизации `services.AddAuthorization`, но закомментируй политику `MustOwnPhoto`
и исправь политику по-умолчанию вот так:
```cs
options.DefaultPolicy = new AuthorizationPolicyBuilder()
    .RequireAuthenticatedUser()
    .Build();
```


В `RemotePhotosRepository.cs` убери имя схемы в вызовах `GetTokenAsync`: в них будет использоваться схема по-умолчанию,
которая будет создана позже.


В `PhotoController.cs` в методе `GetOwnerId` верни использование `ClaimTypes.NameIdentifier`, ведь теперь будут
использоваться только идентификаторы пользователей из `IdentityServer`.


В `DataExtensions.cs` закомментируй все в методе `PrepareDB`, потому что пользователи хранятся в `IdentityServer`,
а фотографии в `PhotosService`.


В `Startup.cs` закомментируй вызов `endpoints.MapRazorPages();`, потому что они использовались только для `Identity`.


Разборка на этом закончена. Теперь надо собрать новую аутентификацию.


Прежде всего надо создать cookie-схему, в которую внешние провайдеры, а именно OpenID Connect,
смогут сохранять свою информацию. Поэтому добавь в `IdentityHostingStartup.cs`:
```cs
services.AddAuthentication(options =>
    {
        // NOTE: Схема, которую внешние провайдеры будут использовать для сохранения данных о пользователе
        // NOTE: Так как значение совпадает с DefaultScheme, то эту настройку можно не задавать
        options.DefaultSignInScheme = "Cookie";
        // NOTE: Схема, которая будет вызываться, если у пользователя нет доступа
        options.DefaultChallengeScheme = "Passport";
        // NOTE: Схема на все остальные случаи жизни
        options.DefaultScheme = "Cookie";
    })
    .AddCookie("Cookie", options =>
    {
        // NOTE: Пусть у куки будет имя, которое расшифровывается на странице «Decode»
        options.Cookie.Name = "PhotosApp.Auth";
    });
```


Затем создай вот такой контроллер, чтобы инициировать вход пользователя и обработать выход пользователя:
```cs
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace PhotosApp.Controllers
{
    public class PassportController : Controller
    {
        // NOTE: Неаутентифицированный пользователь будет отправляться на вход в DefaultChallengeScheme,
        // а затем возвращаться сюда и отсюда перенаправляться на главную страницу.
        [Authorize]
        public IActionResult Login()
        {
            return Redirect("/");
        }

        // NOTE: Сначала происходит выход из приложения, а затем на сервере авторизации
        [Authorize]
        public IActionResult Logout()
        {
            return SignOut("Cookie", "Passport");
        }
    }
}
```

Можешь заменить реализацию метода Login на более явную:
```cs
// [Authorize]
public IActionResult Login()
{
    if (!User.Identity.IsAuthenticated)
        return Challenge();

    return Redirect("/");
}
```


Наконец, создай ссылки для входа. Для этого замени содержимое `Views/Shared/_LoginPartial.cshtml` на такое:
```cshtml
<ul class="navbar-nav">
    @if (User.Identity.IsAuthenticated)
    {
        <li class="nav-item">
            <form id="logoutForm" class="form-inline" asp-controller="Passport" asp-action="Logout">
                <button id="logout" type="submit" class="nav-link btn btn-link text-dark">Logout</button>
            </form>
        </li>
    }
    else
    {
        <li class="nav-item">
            <a class="nav-link text-dark" id="login" asp-controller="Passport" asp-action="Login">Login</a>
        </li>
    }
</ul>
```

А в `Views/Photo/Index.cshtml` замени
```cshtml
<a asp-area="Identity" asp-page="/Account/Login">
```
на
```cshtml
<a asp-controller="Passport" asp-action="Login">
```


Теперь можно убедиться, что аутентификация через `IdentityServer` прекрасно работает!
И вход, и выход. И для `vicky@gmail.com`, и для `alice`.
